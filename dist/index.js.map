{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils.js","webpack:///./src/CollisionBox.js","webpack:///./src/StartBtn.js","webpack:///./src/Obstacle.js","webpack:///./src/NightMode.js","webpack:///./src/HorizonLine.js","webpack:///./src/Cloud.js","webpack:///./src/Horizon.js","webpack:///./src/runner.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","getRandomNum","min","max","Math","floor","random","IS_HIDPI","window","devicePixelRatio","FPS","x","y","w","h","this","width","height","StartBtn","canvas","restartImgPos","dimensions","canvasCtx","getContext","canvasDimensions","draw","RESTART_WIDTH","RESTART_HEIGHT","updateDimensions","opt_height","WIDTH","HEIGHT","centerX","restartSourceWidth","restartSourceHeight","restartTargetX","restartTargetY","drawImage","Runner","imageSprite","utils","CollisionBox","Obstacle","type","spriteImgPos","gapCoefficient","speed","opt_xOffset","spritePos","typeConfig","size","MAX_OBSTACLE_LENGTH","remove","xPos","yPos","collisionBoxes","gap","speedOffset","currentFrame","timer","init","MAX_GAP_COEFFICIENT","cloneCollisionBoxes","multipleSpeed","Array","isArray","yPosConfig","IS_MOBILE","yPosMobile","length","getGap","sourceWidth","sourceHeight","sourceX","update","deltaTime","numFrames","frameRate","isVisible","minGap","round","maxGap","types","minSpeed","NightMode","containerWidth","currentPhase","opacity","stars","drawStars","placeStars","config","FADE_SPEED","MOON_SPEED","NUM_STARS","STAR_SIZE","STAR_SPEED","STAR_MAX_Y","phases","activated","delta","updateXPos","currentPos","moonSourceWidth","moonSourceHeight","moonSourceX","moonOutputWidth","starSize","starSourceX","spriteDefinition","LDPI","STAR","HDPI","save","globalAlpha","sourceY","restore","segmentSize","reset","HorizonLine","sourceDimensions","sourceXPos","bumpThreshold","setSourceDimensions","YPOS","dimension","getRandomType","pos","increment","line1","line2","Cloud","cloudGap","MIN_CLOUD_GAP","MAX_CLOUD_GAP","MAX_SKY_LEVEL","MIN_SKY_LEVEL","ceil","Horizon","obstacles","obstacleHistory","horizonOffsets","cloudFrequency","CLOUD_FREQUENCY","nightMode","clouds","cloudSpeed","BG_CLOUD_SPEED","horizonLine","BUMPY_THRESHOLD","HORIZON_HEIGHT","MAX_CLOUDS","addCloud","HORIZON","MOON","currentSpeed","updateObstacles","showNightMode","runningTime","updateClouds","numClouds","lastCloud","filter","obj","updatedObstacles","slice","obstacle","shift","lastObstacle","followingObstacleCreated","addNewObstacle","removeFirstObstacle","obstacleTypeIndex","obstacleType","duplicateObstacleCheck","obstacleSpritePos","push","unshift","splice","MAX_OBSTACLE_DUPLICATION","nextObstacleType","duplicateCount","resize","CLOUD","outerContainerId","opt_config","instance_","outerContainerEl","document","querySelector","containerEl","snackbarEl","defaultDimensions","tRex","distanceMeter","distanceRan","highestScore","time","msPerFrame","SPEED","playing","crashed","paused","inverted","invertTimer","resizeTimerId_","playCount","audioBuffer","soundFx","audioContext","images","imagesLoaded","loadImages","IS_IOS","test","navigator","platform","userAgent","ACCELERATION","BOTTOM_PAD","CLEAR_TIME","GAMEOVER_CLEAR_TIME","GAP_COEFFICIENT","GRAVITY","INITIAL_JUMP_VELOCITY","INVERT_FADE_DURATION","INVERT_DISTANCE","MAX_BLINK_COUNT","MAX_SPEED","MIN_JUMP_HEIGHT","MOBILE_SPEED_COEFFICIENT","RESOURCE_TEMPLATE_ID","SPEED_DROP_COEFFICIENT","ARCADE_MODE_INITIAL_TOP_POSITION","ARCADE_MODE_TOP_POSITION_PERCENT","classes","ARCADE_MODE","CANVAS","CONTAINER","CRASHED","ICON","INVERTED","SNACKBAR","SNACKBAR_SHOW","TOUCH_CONTROLLER","CACTUS_LARGE","CACTUS_SMALL","PTERODACTYL","RESTART","TEXT_SPRITE","TREX","sounds","BUTTON_PRESS","HIT","SCORE","keycodes","JUMP","38","32","DUCK","40","13","events","ANIM_END","CLICK","KEYDOWN","KEYUP","MOUSEDOWN","MOUSEUP","RESIZE","TOUCHEND","TOUCHSTART","VISIBILITY","BLUR","FOCUS","LOAD","isDisabled","loadTimeData","valueExists","setupDisabledRunner","createElement","className","textContent","getValue","appendChild","addEventListener","e","keyCode","classList","add","bind","updateConfigSetting","setting","undefined","setJumpVelocity","setSpeed","getElementById","spriteDef","complete","loadSounds","AudioContext","resourceTemplate","content","sound","soundSrc","src","buffer","decodeBase64ToArrayBuffer","substr","indexOf","decodeAudioData","index","audioData","opt_speed","mobileSpeed","container","opt_classname","adjustDimensions","PLAYER","fillStyle","fill","updateCanvasScaling","horizon","DistanceMeter","Trex","createTouchController","startListening","debounceResize","touchController","hideTouchController","style","showTouchController","setInterval","clearInterval","boxStyles","getComputedStyle","padding","Number","paddingLeft","offsetWidth","isArcadeMode","setArcadeModeContainerScale","calcXPos","clearCanvas","stop","gameOverPanel","playIntro","restart","playingIntro","setTimeout","startGame","setArcadeMode","webkitAnimation","onVisibilityChange","clearRect","updatePending","now","getTimeStamp","jumping","updateJump","hasObstacles","jumpCount","opt_canvasCtx","tRexBox","obstacleBox","drawCollisionBoxes","boxCompare","tRexCollisionBoxes","ducking","DUCKING","RUNNING","t","adjTrexBox","createAdjustedCollisionBox","adjObstacleBox","checkForCollision","gameOver","playSound","invertTrigger","invert","actualDistance","getActualDistance","blinkCount","scheduleNextUpdate","handleEvent","evtType","onKeyDown","onKeyUp","once","stopListening","removeEventListener","preventDefault","currentTarget","errorPageController","trackEasterEgg","startJump","setSpeedDrop","setDuck","String","isjumpKey","isRunning","endJump","speedDrop","isLeftClickOnCanvas","play","button","target","raqId","requestAnimationFrame","duration","vibrate","achievement","status","GameOverPanel","setHighScore","title","cancelAnimationFrame","body","windowHeight","innerHeight","scaleHeight","scaleWidth","innerWidth","scale","scaledCanvasHeight","translateY","transform","hidden","webkitHidden","visibilityState","soundBuffer","sourceNode","createBufferSource","connect","destination","start","toggle","opt_width","context","backingStoreRatio","webkitBackingStorePixelRatio","ratio","oldWidth","oldHeight","base64String","len","str","atob","arrayBuffer","ArrayBuffer","bytes","Uint8Array","charCodeAt","Date","getTime","performance","textImgPos","box","adjustment","strokeStyle","strokeRect","obstacleBoxX","groundYPos","currentAnimFrames","blinkDelay","animStartTime","WAITING","jumpVelocity","reachedMinHeight","jumpspotX","canvasWidth","image","currentDistance","maxScore","highScore","digits","defaultString","flashTimer","flashIterations","maxScoreUnits","MAX_DISTANCE_UNITS","TEXT_X","TEXT_Y","TEXT_WIDTH","TEXT_HEIGHT","textSourceX","textSourceY","textSourceWidth","textSourceHeight","textTargetX","textTargetY","textTargetWidth","textTargetHeight","DROP_VELOCITY","HEIGHT_DUCK","INIITAL_JUMP_VELOCITY","INTRO_DURATION","MAX_JUMP_HEIGHT","SPRITE_WIDTH","START_X_POS","WIDTH_DUCK","JUMPING","BLINK_TIMING","animFrames","frames","minJumpHeight","opt_status","setBlinkDelay","blink","framesElapsed","isDucking","midair","DEST_WIDTH","ACHIEVEMENT_DISTANCE","COEFFICIENT","FLASH_DURATION","FLASH_ITERATIONS","maxDistanceStr","parseInt","digitPos","opt_highScore","targetX","targetY","targetWidth","targetHeight","highScoreX","translate","distance","paint","distanceStr","split","drawHighScore","highScoreStr","concat","onload"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = {\r\n    /**\r\n     * Get random number.\r\n     * @param {number} min\r\n     * @param {number} max\r\n     * @param {number}\r\n     */\r\n    getRandomNum: function (min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    },\r\n    IS_HIDPI: window.devicePixelRatio > 1,\r\n    FPS: 60\r\n}","/**\r\n * Collision box object.\r\n * @param {number} x X position.\r\n * @param {number} y Y Position.\r\n * @param {number} w Width.\r\n * @param {number} h Height.\r\n */\r\nfunction CollisionBox(x, y, w, h) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = w;\r\n    this.height = h;\r\n};\r\n\r\nmodule.exports = CollisionBox;","var utils = require('./utils');\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\n\r\n/**\r\n * Game over panel.\r\n * @param {!HTMLCanvasElement} canvas\r\n * @param {Object} textImgPos\r\n * @param {Object} restartImgPos\r\n * @param {!Object} dimensions Canvas dimensions.\r\n * @constructor\r\n */\r\nfunction StartBtn(canvas, restartImgPos, dimensions) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.canvasDimensions = dimensions;\r\n    this.restartImgPos = restartImgPos;\r\n    this.draw();\r\n};\r\n\r\n\r\n/**\r\n * Dimensions used in the panel.\r\n * @enum {number}\r\n */\r\nStartBtn.dimensions = {\r\n    RESTART_WIDTH: 36,\r\n    RESTART_HEIGHT: 32\r\n};\r\n\r\n\r\nStartBtn.prototype = {\r\n    /**\r\n     * Update the panel dimensions.\r\n     * @param {number} width New canvas width.\r\n     * @param {number} opt_height Optional new canvas height.\r\n     */\r\n    updateDimensions: function (width, opt_height) {\r\n        this.canvasDimensions.WIDTH = width;\r\n        if (opt_height) {\r\n            this.canvasDimensions.HEIGHT = opt_height;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Draw the panel.\r\n     */\r\n    draw: function () {\r\n        var dimensions = StartBtn.dimensions;\r\n\r\n        var centerX = this.canvasDimensions.WIDTH / 2;\r\n\r\n\r\n        var restartSourceWidth = dimensions.RESTART_WIDTH;\r\n        var restartSourceHeight = dimensions.RESTART_HEIGHT;\r\n        var restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);\r\n        var restartTargetY = this.canvasDimensions.HEIGHT / 2;\r\n\r\n        if (IS_HIDPI) {\r\n            restartSourceWidth *= 2;\r\n            restartSourceHeight *= 2;\r\n        }\r\n\r\n        // Restart button.\r\n        this.canvasCtx.drawImage(Runner.imageSprite,\r\n            this.restartImgPos.x, this.restartImgPos.y,\r\n            restartSourceWidth, restartSourceHeight,\r\n            restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,\r\n            dimensions.RESTART_HEIGHT);\r\n    }\r\n};\r\n\r\n\r\nmodule.exports = StartBtn;","var utils = require('./utils');\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\nvar CollisionBox = require('./CollisionBox');\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\nvar FPS = utils.FPS;\r\n\r\n/**\r\n * Obstacle.\r\n * @param {HTMLCanvasCtx} canvasCtx\r\n * @param {Obstacle.type} type\r\n * @param {Object} spritePos Obstacle position in sprite.\r\n * @param {Object} dimensions\r\n * @param {number} gapCoefficient Mutipler in determining the gap.\r\n * @param {number} speed\r\n * @param {number} opt_xOffset\r\n */\r\nfunction Obstacle(canvasCtx, type, spriteImgPos, dimensions,\r\n    gapCoefficient, speed, opt_xOffset) {\r\n\r\n    this.canvasCtx = canvasCtx;\r\n    this.spritePos = spriteImgPos;\r\n    this.typeConfig = type;\r\n    this.gapCoefficient = gapCoefficient;\r\n    this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);\r\n    this.dimensions = dimensions;\r\n    this.remove = false;\r\n    this.xPos = dimensions.WIDTH + (opt_xOffset || 0);\r\n    this.yPos = 0;\r\n    this.width = 0;\r\n    this.collisionBoxes = [];\r\n    this.gap = 0;\r\n    this.speedOffset = 0;\r\n\r\n    // For animated obstacles.\r\n    this.currentFrame = 0;\r\n    this.timer = 0;\r\n\r\n    this.init(speed);\r\n};\r\n\r\n/**\r\n * Coefficient for calculating the maximum gap.\r\n * @const\r\n */\r\nObstacle.MAX_GAP_COEFFICIENT = 1.5;\r\n\r\n/**\r\n * Maximum obstacle grouping count.\r\n * @const\r\n */\r\nObstacle.MAX_OBSTACLE_LENGTH = 3,\r\n\r\n\r\n    Obstacle.prototype = {\r\n        /**\r\n         * Initialise the DOM for the obstacle.\r\n         * @param {number} speed\r\n         */\r\n        init: function (speed) {\r\n            this.cloneCollisionBoxes();\r\n\r\n            // Only allow sizing if we're at the right speed.\r\n            if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {\r\n                this.size = 1;\r\n            }\r\n\r\n            this.width = this.typeConfig.width * this.size;\r\n\r\n            // Check if obstacle can be positioned at various heights.\r\n            if (Array.isArray(this.typeConfig.yPos)) {\r\n                var yPosConfig = IS_MOBILE ? this.typeConfig.yPosMobile :\r\n                    this.typeConfig.yPos;\r\n                this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];\r\n            } else {\r\n                this.yPos = this.typeConfig.yPos;\r\n            }\r\n\r\n            this.draw();\r\n\r\n            // Make collision box adjustments,\r\n            // Central box is adjusted to the size as one box.\r\n            //      ____        ______        ________\r\n            //    _|   |-|    _|     |-|    _|       |-|\r\n            //   | |<->| |   | |<--->| |   | |<----->| |\r\n            //   | | 1 | |   | |  2  | |   | |   3   | |\r\n            //   |_|___|_|   |_|_____|_|   |_|_______|_|\r\n            //\r\n            if (this.size > 1) {\r\n                this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -\r\n                    this.collisionBoxes[2].width;\r\n                this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;\r\n            }\r\n\r\n            // For obstacles that go at a different speed from the horizon.\r\n            if (this.typeConfig.speedOffset) {\r\n                this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :\r\n                    -this.typeConfig.speedOffset;\r\n            }\r\n\r\n            this.gap = this.getGap(this.gapCoefficient, speed);\r\n        },\r\n\r\n        /**\r\n         * Draw and crop based on size.\r\n         */\r\n        draw: function () {\r\n            var sourceWidth = this.typeConfig.width;\r\n            var sourceHeight = this.typeConfig.height;\r\n\r\n            if (IS_HIDPI) {\r\n                sourceWidth = sourceWidth * 2;\r\n                sourceHeight = sourceHeight * 2;\r\n            }\r\n\r\n            // X position in sprite.\r\n            var sourceX = (sourceWidth * this.size) * (0.5 * (this.size - 1)) +\r\n                this.spritePos.x;\r\n\r\n            // Animation frames.\r\n            if (this.currentFrame > 0) {\r\n                sourceX += sourceWidth * this.currentFrame;\r\n            }\r\n\r\n            this.canvasCtx.drawImage(Runner.imageSprite,\r\n                sourceX, this.spritePos.y,\r\n                sourceWidth * this.size, sourceHeight,\r\n                this.xPos, this.yPos,\r\n                this.typeConfig.width * this.size, this.typeConfig.height);\r\n        },\r\n\r\n        /**\r\n         * Obstacle frame update.\r\n         * @param {number} deltaTime\r\n         * @param {number} speed\r\n         */\r\n        update: function (deltaTime, speed) {\r\n            if (!this.remove) {\r\n                if (this.typeConfig.speedOffset) {\r\n                    speed += this.speedOffset;\r\n                }\r\n                this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);\r\n\r\n                // Update frame\r\n                if (this.typeConfig.numFrames) {\r\n                    this.timer += deltaTime;\r\n                    if (this.timer >= this.typeConfig.frameRate) {\r\n                        this.currentFrame =\r\n                            this.currentFrame == this.typeConfig.numFrames - 1 ?\r\n                                0 : this.currentFrame + 1;\r\n                        this.timer = 0;\r\n                    }\r\n                }\r\n                this.draw();\r\n\r\n                if (!this.isVisible()) {\r\n                    this.remove = true;\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Calculate a random gap size.\r\n         * - Minimum gap gets wider as speed increses\r\n         * @param {number} gapCoefficient\r\n         * @param {number} speed\r\n         * @return {number} The gap size.\r\n         */\r\n        getGap: function (gapCoefficient, speed) {\r\n            var minGap = Math.round(this.width * speed +\r\n                this.typeConfig.minGap * gapCoefficient);\r\n            var maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);\r\n            return getRandomNum(minGap, maxGap);\r\n        },\r\n\r\n        /**\r\n         * Check if obstacle is visible.\r\n         * @return {boolean} Whether the obstacle is in the game area.\r\n         */\r\n        isVisible: function () {\r\n            return this.xPos + this.width > 0;\r\n        },\r\n\r\n        /**\r\n         * Make a copy of the collision boxes, since these will change based on\r\n         * obstacle type and size.\r\n         */\r\n        cloneCollisionBoxes: function () {\r\n            var collisionBoxes = this.typeConfig.collisionBoxes;\r\n\r\n            for (var i = collisionBoxes.length - 1; i >= 0; i--) {\r\n                this.collisionBoxes[i] = new CollisionBox(collisionBoxes[i].x,\r\n                    collisionBoxes[i].y, collisionBoxes[i].width,\r\n                    collisionBoxes[i].height);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n/**\r\n * Obstacle definitions.\r\n * minGap: minimum pixel space betweeen obstacles.\r\n * multipleSpeed: Speed at which multiples are allowed.\r\n * speedOffset: speed faster / slower than the horizon.\r\n * minSpeed: Minimum speed which the obstacle can make an appearance.\r\n */\r\nObstacle.types = [\r\n    {\r\n        type: 'CACTUS_SMALL',\r\n        width: 17,\r\n        height: 35,\r\n        yPos: 105,\r\n        multipleSpeed: 4,\r\n        minGap: 120,\r\n        minSpeed: 0,\r\n        collisionBoxes: [\r\n            new CollisionBox(0, 7, 5, 27),\r\n            new CollisionBox(4, 0, 6, 34),\r\n            new CollisionBox(10, 4, 7, 14)\r\n        ]\r\n    },\r\n    {\r\n        type: 'CACTUS_LARGE',\r\n        width: 25,\r\n        height: 50,\r\n        yPos: 90,\r\n        multipleSpeed: 7,\r\n        minGap: 120,\r\n        minSpeed: 0,\r\n        collisionBoxes: [\r\n            new CollisionBox(0, 12, 7, 38),\r\n            new CollisionBox(8, 0, 7, 49),\r\n            new CollisionBox(13, 10, 10, 38)\r\n        ]\r\n    },\r\n    {\r\n        type: 'PTERODACTYL',\r\n        width: 46,\r\n        height: 40,\r\n        yPos: [100, 75, 50], // Variable height.\r\n        yPosMobile: [100, 50], // Variable height mobile.\r\n        multipleSpeed: 999,\r\n        minSpeed: 8.5,\r\n        minGap: 150,\r\n        collisionBoxes: [\r\n            new CollisionBox(15, 15, 16, 5),\r\n            new CollisionBox(18, 21, 24, 6),\r\n            new CollisionBox(2, 14, 4, 3),\r\n            new CollisionBox(6, 10, 4, 7),\r\n            new CollisionBox(10, 8, 6, 9)\r\n        ],\r\n        numFrames: 2,\r\n        frameRate: 1000 / 6,\r\n        speedOffset: .8\r\n    }\r\n];\r\n\r\nmodule.exports = Obstacle;","\r\nvar utils = require('./utils');\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\n/**\r\n * Nightmode shows a moon and stars on the horizon.\r\n */\r\nfunction NightMode(canvas, spritePos, containerWidth) {\r\n    this.spritePos = spritePos;\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.xPos = containerWidth - 50;\r\n    this.yPos = 30;\r\n    this.currentPhase = 0;\r\n    this.opacity = 0;\r\n    this.containerWidth = containerWidth;\r\n    this.stars = [];\r\n    this.drawStars = false;\r\n    this.placeStars();\r\n};\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nNightMode.config = {\r\n    FADE_SPEED: 0.035,\r\n    HEIGHT: 40,\r\n    MOON_SPEED: 0.25,\r\n    NUM_STARS: 2,\r\n    STAR_SIZE: 9,\r\n    STAR_SPEED: 0.3,\r\n    STAR_MAX_Y: 70,\r\n    WIDTH: 20\r\n};\r\n\r\nNightMode.phases = [140, 120, 100, 60, 40, 20, 0];\r\n\r\nNightMode.prototype = {\r\n    /**\r\n     * Update moving moon, changing phases.\r\n     * @param {boolean} activated Whether night mode is activated.\r\n     * @param {number} delta\r\n     */\r\n    update: function (activated, delta) {\r\n        // Moon phase.\r\n        if (activated && this.opacity == 0) {\r\n            this.currentPhase++;\r\n\r\n            if (this.currentPhase >= NightMode.phases.length) {\r\n                this.currentPhase = 0;\r\n            }\r\n        }\r\n\r\n        // Fade in / out.\r\n        if (activated && (this.opacity < 1 || this.opacity == 0)) {\r\n            this.opacity += NightMode.config.FADE_SPEED;\r\n        } else if (this.opacity > 0) {\r\n            this.opacity -= NightMode.config.FADE_SPEED;\r\n        }\r\n\r\n        // Set moon positioning.\r\n        if (this.opacity > 0) {\r\n            this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);\r\n\r\n            // Update stars.\r\n            if (this.drawStars) {\r\n                for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\r\n                    this.stars[i].x = this.updateXPos(this.stars[i].x,\r\n                        NightMode.config.STAR_SPEED);\r\n                }\r\n            }\r\n            this.draw();\r\n        } else {\r\n            this.opacity = 0;\r\n            this.placeStars();\r\n        }\r\n        this.drawStars = true;\r\n    },\r\n\r\n    updateXPos: function (currentPos, speed) {\r\n        if (currentPos < -NightMode.config.WIDTH) {\r\n            currentPos = this.containerWidth;\r\n        } else {\r\n            currentPos -= speed;\r\n        }\r\n        return currentPos;\r\n    },\r\n\r\n    draw: function () {\r\n        var moonSourceWidth = this.currentPhase == 3 ? NightMode.config.WIDTH * 2 :\r\n            NightMode.config.WIDTH;\r\n        var moonSourceHeight = NightMode.config.HEIGHT;\r\n        var moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];\r\n        var moonOutputWidth = moonSourceWidth;\r\n        var starSize = NightMode.config.STAR_SIZE;\r\n        var starSourceX = Runner.spriteDefinition.LDPI.STAR.x;\r\n\r\n        if (IS_HIDPI) {\r\n            moonSourceWidth *= 2;\r\n            moonSourceHeight *= 2;\r\n            moonSourceX = this.spritePos.x +\r\n                (NightMode.phases[this.currentPhase] * 2);\r\n            starSize *= 2;\r\n            starSourceX = Runner.spriteDefinition.HDPI.STAR.x;\r\n        }\r\n\r\n        this.canvasCtx.save();\r\n        this.canvasCtx.globalAlpha = this.opacity;\r\n\r\n        // Stars.\r\n        if (this.drawStars) {\r\n            for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\r\n                this.canvasCtx.drawImage(Runner.imageSprite,\r\n                    starSourceX, this.stars[i].sourceY, starSize, starSize,\r\n                    Math.round(this.stars[i].x), this.stars[i].y,\r\n                    NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);\r\n            }\r\n        }\r\n\r\n        // Moon.\r\n        this.canvasCtx.drawImage(Runner.imageSprite, moonSourceX,\r\n            this.spritePos.y, moonSourceWidth, moonSourceHeight,\r\n            Math.round(this.xPos), this.yPos,\r\n            moonOutputWidth, NightMode.config.HEIGHT);\r\n\r\n        this.canvasCtx.globalAlpha = 1;\r\n        this.canvasCtx.restore();\r\n    },\r\n\r\n    // Do star placement.\r\n    placeStars: function () {\r\n        var segmentSize = Math.round(this.containerWidth /\r\n            NightMode.config.NUM_STARS);\r\n\r\n        for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\r\n            this.stars[i] = {};\r\n            this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));\r\n            this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);\r\n\r\n            if (IS_HIDPI) {\r\n                this.stars[i].sourceY = Runner.spriteDefinition.HDPI.STAR.y +\r\n                    NightMode.config.STAR_SIZE * 2 * i;\r\n            } else {\r\n                this.stars[i].sourceY = Runner.spriteDefinition.LDPI.STAR.y +\r\n                    NightMode.config.STAR_SIZE * i;\r\n            }\r\n        }\r\n    },\r\n\r\n    reset: function () {\r\n        this.currentPhase = 0;\r\n        this.opacity = 0;\r\n        this.update(false);\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = NightMode;","var utils = require('./utils');\r\n\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\nvar FPS = utils.FPS;\r\n/**\r\n * Horizon Line.\r\n * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {Object} spritePos Horizon position in sprite.\r\n * @constructor\r\n */\r\nfunction HorizonLine(canvas, spritePos) {\r\n    this.spritePos = spritePos;\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.sourceDimensions = {};\r\n    this.dimensions = HorizonLine.dimensions;\r\n    this.sourceXPos = [this.spritePos.x, this.spritePos.x +\r\n        this.dimensions.WIDTH];\r\n    this.xPos = [];\r\n    this.yPos = 0;\r\n    this.bumpThreshold = 0.5;\r\n\r\n    this.setSourceDimensions();\r\n    this.draw();\r\n};\r\n\r\n\r\n/**\r\n * Horizon line dimensions.\r\n * @enum {number}\r\n */\r\nHorizonLine.dimensions = {\r\n    WIDTH: 600,\r\n    HEIGHT: 12,\r\n    YPOS: 127\r\n};\r\n\r\n\r\nHorizonLine.prototype = {\r\n    /**\r\n     * Set the source dimensions of the horizon line.\r\n     */\r\n    setSourceDimensions: function () {\r\n\r\n        for (var dimension in HorizonLine.dimensions) {\r\n            if (IS_HIDPI) {\r\n                if (dimension != 'YPOS') {\r\n                    this.sourceDimensions[dimension] =\r\n                        HorizonLine.dimensions[dimension] * 2;\r\n                }\r\n            } else {\r\n                this.sourceDimensions[dimension] =\r\n                    HorizonLine.dimensions[dimension];\r\n            }\r\n            this.dimensions[dimension] = HorizonLine.dimensions[dimension];\r\n        }\r\n\r\n        this.xPos = [0, HorizonLine.dimensions.WIDTH];\r\n        this.yPos = HorizonLine.dimensions.YPOS;\r\n    },\r\n\r\n    /**\r\n     * Return the crop x position of a type.\r\n     */\r\n    getRandomType: function () {\r\n        return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;\r\n    },\r\n\r\n    /**\r\n     * Draw the horizon line.\r\n     */\r\n    draw: function () {\r\n        this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],\r\n            this.spritePos.y,\r\n            this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,\r\n            this.xPos[0], this.yPos,\r\n            this.dimensions.WIDTH, this.dimensions.HEIGHT);\r\n\r\n        this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],\r\n            this.spritePos.y,\r\n            this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,\r\n            this.xPos[1], this.yPos,\r\n            this.dimensions.WIDTH, this.dimensions.HEIGHT);\r\n    },\r\n\r\n    /**\r\n     * Update the x position of an indivdual piece of the line.\r\n     * @param {number} pos Line position.\r\n     * @param {number} increment\r\n     */\r\n    updateXPos: function (pos, increment) {\r\n        var line1 = pos;\r\n        var line2 = pos == 0 ? 1 : 0;\r\n\r\n        this.xPos[line1] -= increment;\r\n        this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;\r\n\r\n        if (this.xPos[line1] <= -this.dimensions.WIDTH) {\r\n            this.xPos[line1] += this.dimensions.WIDTH * 2;\r\n            this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;\r\n            this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Update the horizon line.\r\n     * @param {number} deltaTime\r\n     * @param {number} speed\r\n     */\r\n    update: function (deltaTime, speed) {\r\n        var increment = Math.floor(speed * (FPS / 1000) * deltaTime);\r\n\r\n        if (this.xPos[0] <= 0) {\r\n            this.updateXPos(0, increment);\r\n        } else {\r\n            this.updateXPos(1, increment);\r\n        }\r\n        this.draw();\r\n    },\r\n\r\n    /**\r\n     * Reset horizon to the starting position.\r\n     */\r\n    reset: function () {\r\n        this.xPos[0] = 0;\r\n        this.xPos[1] = HorizonLine.dimensions.WIDTH;\r\n    }\r\n};\r\n\r\nmodule.exports = HorizonLine;","var utils = require('./utils');\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\n\r\n/**\r\n * Cloud background item.\r\n * Similar to an obstacle object but without collision boxes.\r\n * @param {HTMLCanvasElement} canvas Canvas element.\r\n * @param {Object} spritePos Position of image in sprite.\r\n * @param {number} containerWidth\r\n */\r\nfunction Cloud(canvas, spritePos, containerWidth) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = this.canvas.getContext('2d');\r\n    this.spritePos = spritePos;\r\n    this.containerWidth = containerWidth;\r\n    this.xPos = containerWidth;\r\n    this.yPos = 0;\r\n    this.remove = false;\r\n    this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP,\r\n        Cloud.config.MAX_CLOUD_GAP);\r\n\r\n    this.init();\r\n};\r\n\r\n\r\n/**\r\n * Cloud object config.\r\n * @enum {number}\r\n */\r\nCloud.config = {\r\n    HEIGHT: 14,\r\n    MAX_CLOUD_GAP: 400,\r\n    MAX_SKY_LEVEL: 30,\r\n    MIN_CLOUD_GAP: 100,\r\n    MIN_SKY_LEVEL: 71,\r\n    WIDTH: 46\r\n};\r\n\r\nCloud.prototype = {\r\n    /**\r\n     * Initialise the cloud. Sets the Cloud height.\r\n     */\r\n    init: function () {\r\n        this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,\r\n            Cloud.config.MIN_SKY_LEVEL);\r\n        this.draw();\r\n    },\r\n\r\n    /**\r\n     * Draw the cloud.\r\n     */\r\n    draw: function () {\r\n        this.canvasCtx.save();\r\n        var sourceWidth = Cloud.config.WIDTH;\r\n        var sourceHeight = Cloud.config.HEIGHT;\r\n\r\n        if (IS_HIDPI) {\r\n            sourceWidth = sourceWidth * 2;\r\n            sourceHeight = sourceHeight * 2;\r\n        }\r\n\r\n        this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,\r\n            this.spritePos.y,\r\n            sourceWidth, sourceHeight,\r\n            this.xPos, this.yPos,\r\n            Cloud.config.WIDTH, Cloud.config.HEIGHT);\r\n\r\n        this.canvasCtx.restore();\r\n    },\r\n\r\n    /**\r\n     * Update the cloud position.\r\n     * @param {number} speed\r\n     */\r\n    update: function (speed) {\r\n        if (!this.remove) {\r\n            this.xPos -= Math.ceil(speed);\r\n            this.draw();\r\n\r\n            // Mark as removeable if no longer in the canvas.\r\n            if (!this.isVisible()) {\r\n                this.remove = true;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check if the cloud is visible on the stage.\r\n     * @return {boolean}\r\n     */\r\n    isVisible: function () {\r\n        return this.xPos + Cloud.config.WIDTH > 0;\r\n    }\r\n};\r\n\r\nmodule.exports = Cloud;","var Cloud = require('./Cloud'),\r\n    HorizonLine = require('./HorizonLine'),\r\n    NightMode = require('./NightMode'),\r\n    utils = require('./utils'),\r\n    Obstacle = require('./Obstacle');\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\n\r\n/**\r\n     * Horizon background class.\r\n     * @param {HTMLCanvasElement} canvas\r\n     * @param {Object} spritePos Sprite positioning.\r\n     * @param {Object} dimensions Canvas dimensions.\r\n     * @param {number} gapCoefficient\r\n     * @constructor\r\n     */\r\n    function Horizon(canvas, spritePos, dimensions, gapCoefficient) {\r\n        this.canvas = canvas;\r\n        this.canvasCtx = this.canvas.getContext('2d');\r\n        this.config = Horizon.config;\r\n        this.dimensions = dimensions;\r\n        this.gapCoefficient = gapCoefficient;\r\n        this.obstacles = [];\r\n        this.obstacleHistory = [];\r\n        this.horizonOffsets = [0, 0];\r\n        this.cloudFrequency = this.config.CLOUD_FREQUENCY;\r\n        this.spritePos = spritePos;\r\n        this.nightMode = null;\r\n\r\n        // Cloud\r\n        this.clouds = [];\r\n        this.cloudSpeed = this.config.BG_CLOUD_SPEED;\r\n\r\n        // Horizon\r\n        this.horizonLine = null;\r\n        this.init();\r\n    };\r\n\r\n\r\n    /**\r\n     * Horizon config.\r\n     * @enum {number}\r\n     */\r\n    Horizon.config = {\r\n        BG_CLOUD_SPEED: 0.2,\r\n        BUMPY_THRESHOLD: .3,\r\n        CLOUD_FREQUENCY: .5,\r\n        HORIZON_HEIGHT: 16,\r\n        MAX_CLOUDS: 6\r\n    };\r\n\r\n    Horizon.prototype = {\r\n        /**\r\n         * Initialise the horizon. Just add the line and a cloud. No obstacles.\r\n         */\r\n        init: function () {\r\n            this.addCloud();\r\n            this.horizonLine = new HorizonLine(this.canvas, this.spritePos.HORIZON);\r\n            this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,\r\n                this.dimensions.WIDTH);\r\n        },\r\n\r\n        /**\r\n         * @param {number} deltaTime\r\n         * @param {number} currentSpeed\r\n         * @param {boolean} updateObstacles Used as an override to prevent\r\n         *     the obstacles from being updated / added. This happens in the\r\n         *     ease in section.\r\n         * @param {boolean} showNightMode Night mode activated.\r\n         */\r\n        update: function (deltaTime, currentSpeed, updateObstacles, showNightMode) {\r\n            this.runningTime += deltaTime;\r\n            this.horizonLine.update(deltaTime, currentSpeed);\r\n            this.nightMode.update(showNightMode);\r\n            this.updateClouds(deltaTime, currentSpeed);\r\n\r\n            if (updateObstacles) {\r\n                this.updateObstacles(deltaTime, currentSpeed);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Update the cloud positions.\r\n         * @param {number} deltaTime\r\n         * @param {number} currentSpeed\r\n         */\r\n        updateClouds: function (deltaTime, speed) {\r\n            var cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;\r\n            var numClouds = this.clouds.length;\r\n\r\n            if (numClouds) {\r\n                for (var i = numClouds - 1; i >= 0; i--) {\r\n                    this.clouds[i].update(cloudSpeed);\r\n                }\r\n\r\n                var lastCloud = this.clouds[numClouds - 1];\r\n\r\n                // Check for adding a new cloud.\r\n                if (numClouds < this.config.MAX_CLOUDS &&\r\n                    (this.dimensions.WIDTH - lastCloud.xPos) > lastCloud.cloudGap &&\r\n                    this.cloudFrequency > Math.random()) {\r\n                    this.addCloud();\r\n                }\r\n\r\n                // Remove expired clouds.\r\n                this.clouds = this.clouds.filter(function (obj) {\r\n                    return !obj.remove;\r\n                });\r\n            } else {\r\n                this.addCloud();\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Update the obstacle positions.\r\n         * @param {number} deltaTime\r\n         * @param {number} currentSpeed\r\n         */\r\n        updateObstacles: function (deltaTime, currentSpeed) {\r\n            // Obstacles, move to Horizon layer.\r\n            var updatedObstacles = this.obstacles.slice(0);\r\n\r\n            for (var i = 0; i < this.obstacles.length; i++) {\r\n                var obstacle = this.obstacles[i];\r\n                obstacle.update(deltaTime, currentSpeed);\r\n\r\n                // Clean up existing obstacles.\r\n                if (obstacle.remove) {\r\n                    updatedObstacles.shift();\r\n                }\r\n            }\r\n            this.obstacles = updatedObstacles;\r\n\r\n            if (this.obstacles.length > 0) {\r\n                var lastObstacle = this.obstacles[this.obstacles.length - 1];\r\n\r\n                if (lastObstacle && !lastObstacle.followingObstacleCreated &&\r\n                    lastObstacle.isVisible() &&\r\n                    (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <\r\n                    this.dimensions.WIDTH) {\r\n                    this.addNewObstacle(currentSpeed);\r\n                    lastObstacle.followingObstacleCreated = true;\r\n                }\r\n            } else {\r\n                // Create new obstacles.\r\n                this.addNewObstacle(currentSpeed);\r\n            }\r\n        },\r\n\r\n        removeFirstObstacle: function () {\r\n            this.obstacles.shift();\r\n        },\r\n\r\n        /**\r\n         * Add a new obstacle.\r\n         * @param {number} currentSpeed\r\n         */\r\n        addNewObstacle: function (currentSpeed) {\r\n            var obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);\r\n            var obstacleType = Obstacle.types[obstacleTypeIndex];\r\n\r\n            // Check for multiples of the same type of obstacle.\r\n            // Also check obstacle is available at current speed.\r\n            if (this.duplicateObstacleCheck(obstacleType.type) ||\r\n                currentSpeed < obstacleType.minSpeed) {\r\n                this.addNewObstacle(currentSpeed);\r\n            } else {\r\n                var obstacleSpritePos = this.spritePos[obstacleType.type];\r\n\r\n                this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType,\r\n                    obstacleSpritePos, this.dimensions,\r\n                    this.gapCoefficient, currentSpeed, obstacleType.width));\r\n\r\n                this.obstacleHistory.unshift(obstacleType.type);\r\n\r\n                if (this.obstacleHistory.length > 1) {\r\n                    this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns whether the previous two obstacles are the same as the next one.\r\n         * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.\r\n         * @return {boolean}\r\n         */\r\n        duplicateObstacleCheck: function (nextObstacleType) {\r\n            var duplicateCount = 0;\r\n\r\n            for (var i = 0; i < this.obstacleHistory.length; i++) {\r\n                duplicateCount = this.obstacleHistory[i] == nextObstacleType ?\r\n                    duplicateCount + 1 : 0;\r\n            }\r\n            return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;\r\n        },\r\n\r\n        /**\r\n         * Reset the horizon layer.\r\n         * Remove existing obstacles and reposition the horizon line.\r\n         */\r\n        reset: function () {\r\n            this.obstacles = [];\r\n            this.horizonLine.reset();\r\n            this.nightMode.reset();\r\n        },\r\n\r\n        /**\r\n         * Update the canvas width and scaling.\r\n         * @param {number} width Canvas width.\r\n         * @param {number} height Canvas height.\r\n         */\r\n        resize: function (width, height) {\r\n            this.canvas.width = width;\r\n            this.canvas.height = height;\r\n        },\r\n\r\n        /**\r\n         * Add a new cloud to the horizon.\r\n         */\r\n        addCloud: function () {\r\n            this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,\r\n                this.dimensions.WIDTH));\r\n        }\r\n    };\r\n\r\n    module.exports = Horizon;","\r\nvar Horizon = require('./Horizon'),\r\n    utils = require('./utils');\r\n\r\nvar CollisionBox = require('./CollisionBox'),\r\n    StartBtn = require('./StartBtn');\r\n\r\n/**\r\n * T-Rex runner.\r\n * @param {string} outerContainerId Outer containing element id.\r\n * @param {Object} opt_config\r\n * @constructor\r\n * @export\r\n */\r\nfunction Runner(outerContainerId, opt_config) {\r\n    // Singleton\r\n    if (Runner.instance_) {\r\n        return Runner.instance_;\r\n    }\r\n    Runner.instance_ = this;\r\n\r\n    this.outerContainerEl = document.querySelector(outerContainerId);\r\n    this.containerEl = null;\r\n    this.snackbarEl = null;\r\n\r\n    this.config = opt_config || Runner.config;\r\n    // Logical dimensions of the container.\r\n    this.dimensions = Runner.defaultDimensions;\r\n\r\n    this.canvas = null;\r\n    this.canvasCtx = null;\r\n\r\n    this.tRex = null;\r\n\r\n    this.distanceMeter = null;\r\n    this.distanceRan = 0;\r\n\r\n    this.highestScore = 0;\r\n\r\n    this.time = 0;\r\n    this.runningTime = 0;\r\n    this.msPerFrame = 1000 / FPS;\r\n    this.currentSpeed = this.config.SPEED;\r\n\r\n    this.obstacles = [];\r\n\r\n    this.activated = false; // Whether the easter egg has been activated.\r\n    this.playing = false; // Whether the game is currently in play state.\r\n    this.crashed = false;\r\n    this.paused = false;\r\n    this.inverted = false;\r\n    this.invertTimer = 0;\r\n    this.resizeTimerId_ = null;\r\n\r\n    this.playCount = 0;\r\n\r\n    // Sound FX.\r\n    this.audioBuffer = null;\r\n    this.soundFx = {};\r\n\r\n    // Global web audio context for playing sounds.\r\n    this.audioContext = null;\r\n\r\n    // Images.\r\n    this.images = {};\r\n    this.imagesLoaded = 0;\r\n\r\n    this.loadImages();\r\n}\r\n\r\n\r\nwindow['Runner'] = Runner;\r\n\r\n/**\r\n * Default game width.\r\n * @const\r\n */\r\nvar DEFAULT_WIDTH = 600;\r\n\r\n/**\r\n * Frames per second.\r\n * @const\r\n */\r\nvar FPS = utils.FPS;\r\n\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\n\r\n/** @const */\r\nvar IS_IOS = /iPad|iPhone|iPod/.test(window.navigator.platform);\r\n\r\n/** @const */\r\nvar IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS;\r\n\r\n/** @const */\r\nvar IS_TOUCH_ENABLED = 'ontouchstart' in window;\r\n\r\n/** @const */\r\nvar ARCADE_MODE_URL = 'chrome://dino/';\r\n\r\n/**\r\n * Default game configuration.\r\n * @enum {number}\r\n */\r\nRunner.config = {\r\n    ACCELERATION: 0.001,\r\n    BG_CLOUD_SPEED: 0.2,\r\n    BOTTOM_PAD: 10,\r\n    CLEAR_TIME: 3000,\r\n    CLOUD_FREQUENCY: 0.5,\r\n    GAMEOVER_CLEAR_TIME: 750,\r\n    GAP_COEFFICIENT: 0.6,\r\n    GRAVITY: 0.6,\r\n    INITIAL_JUMP_VELOCITY: 12,\r\n    INVERT_FADE_DURATION: 12000,\r\n    INVERT_DISTANCE: 700,\r\n    MAX_BLINK_COUNT: 3,\r\n    MAX_CLOUDS: 6,\r\n    MAX_OBSTACLE_LENGTH: 3,\r\n    MAX_OBSTACLE_DUPLICATION: 2,\r\n    MAX_SPEED: 13,\r\n    MIN_JUMP_HEIGHT: 35,\r\n    MOBILE_SPEED_COEFFICIENT: 1.2,\r\n    RESOURCE_TEMPLATE_ID: 'audio-resources',\r\n    SPEED: 6,\r\n    SPEED_DROP_COEFFICIENT: 3,\r\n    ARCADE_MODE_INITIAL_TOP_POSITION: 35,\r\n    ARCADE_MODE_TOP_POSITION_PERCENT: 0.1\r\n};\r\n\r\n\r\n/**\r\n * Default dimensions.\r\n * @enum {string}\r\n */\r\nRunner.defaultDimensions = {\r\n    WIDTH: DEFAULT_WIDTH,\r\n    HEIGHT: 150\r\n};\r\n\r\n\r\n/**\r\n * CSS class names.\r\n * @enum {string}\r\n */\r\nRunner.classes = {\r\n    ARCADE_MODE: 'arcade-mode',\r\n    CANVAS: 'runner-canvas',\r\n    CONTAINER: 'runner-container',\r\n    CRASHED: 'crashed',\r\n    ICON: 'icon-offline',\r\n    INVERTED: 'inverted',\r\n    SNACKBAR: 'snackbar',\r\n    SNACKBAR_SHOW: 'snackbar-show',\r\n    TOUCH_CONTROLLER: 'controller'\r\n};\r\n\r\n\r\n/**\r\n * Sprite definition layout of the spritesheet.\r\n * @enum {Object}\r\n */\r\nRunner.spriteDefinition = {\r\n    LDPI: {\r\n        CACTUS_LARGE: { x: 332, y: 2 },\r\n        CACTUS_SMALL: { x: 228, y: 2 },\r\n        CLOUD: { x: 86, y: 2 },\r\n        HORIZON: { x: 2, y: 54 },\r\n        MOON: { x: 484, y: 2 },\r\n        PTERODACTYL: { x: 134, y: 2 },\r\n        RESTART: { x: 2, y: 2 },\r\n        TEXT_SPRITE: { x: 655, y: 2 },\r\n        TREX: { x: 848, y: 2 },\r\n        STAR: { x: 645, y: 2 }\r\n    },\r\n    HDPI: {\r\n        CACTUS_LARGE: { x: 652, y: 2 },\r\n        CACTUS_SMALL: { x: 446, y: 2 },\r\n        CLOUD: { x: 166, y: 2 },\r\n        HORIZON: { x: 2, y: 104 },\r\n        MOON: { x: 954, y: 2 },\r\n        PTERODACTYL: { x: 260, y: 2 },\r\n        RESTART: { x: 2, y: 2 },\r\n        TEXT_SPRITE: { x: 1294, y: 2 },\r\n        TREX: { x: 1678, y: 2 },\r\n        STAR: { x: 1276, y: 2 }\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Sound FX. Reference to the ID of the audio tag on interstitial page.\r\n * @enum {string}\r\n */\r\nRunner.sounds = {\r\n    BUTTON_PRESS: 'offline-sound-press',\r\n    HIT: 'offline-sound-hit',\r\n    SCORE: 'offline-sound-reached'\r\n};\r\n\r\n\r\n/**\r\n * Key code mapping.\r\n * @enum {Object}\r\n */\r\nRunner.keycodes = {\r\n    JUMP: { '38': 1, '32': 1 },  // Up, spacebar\r\n    DUCK: { '40': 1 },  // Down\r\n    RESTART: { '13': 1 }  // Enter\r\n};\r\n\r\n\r\n/**\r\n * Runner event names.\r\n * @enum {string}\r\n */\r\nRunner.events = {\r\n    ANIM_END: 'webkitAnimationEnd',\r\n    CLICK: 'click',\r\n    KEYDOWN: 'keydown',\r\n    KEYUP: 'keyup',\r\n    MOUSEDOWN: 'mousedown',\r\n    MOUSEUP: 'mouseup',\r\n    RESIZE: 'resize',\r\n    TOUCHEND: 'touchend',\r\n    TOUCHSTART: 'touchstart',\r\n    VISIBILITY: 'visibilitychange',\r\n    BLUR: 'blur',\r\n    FOCUS: 'focus',\r\n    LOAD: 'load'\r\n};\r\n\r\nRunner.prototype = {\r\n    /**\r\n     * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.\r\n     * @return {boolean}\r\n     */\r\n    isDisabled: function () {\r\n        return loadTimeData && loadTimeData.valueExists('disabledEasterEgg');\r\n    },\r\n\r\n    /**\r\n     * For disabled instances, set up a snackbar with the disabled message.\r\n     */\r\n    setupDisabledRunner: function () {\r\n        this.containerEl = document.createElement('div');\r\n        this.containerEl.className = Runner.classes.SNACKBAR;\r\n        this.containerEl.textContent = loadTimeData.getValue('disabledEasterEgg');\r\n        this.outerContainerEl.appendChild(this.containerEl);\r\n\r\n        // Show notification when the activation key is pressed.\r\n        document.addEventListener(Runner.events.KEYDOWN, function (e) {\r\n            if (Runner.keycodes.JUMP[e.keyCode]) {\r\n                this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW);\r\n                document.querySelector('.icon').classList.add('icon-disabled');\r\n            }\r\n        }.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Setting individual settings for debugging.\r\n     * @param {string} setting\r\n     * @param {*} value\r\n     */\r\n    updateConfigSetting: function (setting, value) {\r\n        if (setting in this.config && value != undefined) {\r\n            this.config[setting] = value;\r\n\r\n            switch (setting) {\r\n                case 'GRAVITY':\r\n                case 'MIN_JUMP_HEIGHT':\r\n                case 'SPEED_DROP_COEFFICIENT':\r\n                    this.tRex.config[setting] = value;\r\n                    break;\r\n                case 'INITIAL_JUMP_VELOCITY':\r\n                    this.tRex.setJumpVelocity(value);\r\n                    break;\r\n                case 'SPEED':\r\n                    this.setSpeed(value);\r\n                    break;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Cache the appropriate image sprite from the page and get the sprite sheet\r\n     * definition.\r\n     */\r\n    loadImages: function () {\r\n        if (IS_HIDPI) {\r\n            Runner.imageSprite = document.getElementById('offline-resources-2x');\r\n            this.spriteDef = Runner.spriteDefinition.HDPI;\r\n        } else {\r\n            Runner.imageSprite = document.getElementById('offline-resources-1x');\r\n            this.spriteDef = Runner.spriteDefinition.LDPI;\r\n        }\r\n\r\n        if (Runner.imageSprite.complete) {\r\n            this.init();\r\n        } else {\r\n            // If the images are not yet loaded, add a listener.\r\n            Runner.imageSprite.addEventListener(Runner.events.LOAD,\r\n                this.init.bind(this));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Load and decode base 64 encoded sounds.\r\n     */\r\n    loadSounds: function () {\r\n        if (!IS_IOS) {\r\n            this.audioContext = new AudioContext();\r\n\r\n            var resourceTemplate =\r\n                document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;\r\n\r\n            for (var sound in Runner.sounds) {\r\n                var soundSrc =\r\n                    resourceTemplate.getElementById(Runner.sounds[sound]).src;\r\n                soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);\r\n                var buffer = decodeBase64ToArrayBuffer(soundSrc);\r\n\r\n                // Async, so no guarantee of order in array.\r\n                this.audioContext.decodeAudioData(buffer, function (index, audioData) {\r\n                    this.soundFx[index] = audioData;\r\n                }.bind(this, sound));\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the game speed. Adjust the speed accordingly if on a smaller screen.\r\n     * @param {number} opt_speed\r\n     */\r\n    setSpeed: function (opt_speed) {\r\n        var speed = opt_speed || this.currentSpeed;\r\n\r\n        // Reduce the speed on smaller mobile screens.\r\n        if (this.dimensions.WIDTH < DEFAULT_WIDTH) {\r\n            var mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH *\r\n                this.config.MOBILE_SPEED_COEFFICIENT;\r\n            this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;\r\n        } else if (opt_speed) {\r\n            this.currentSpeed = opt_speed;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Game initialiser.\r\n     */\r\n    init: function () {\r\n        // Hide the static icon.\r\n        /*  document.querySelector('.' + Runner.classes.ICON).style.visibility =\r\n           'hidden'; */\r\n\r\n        this.adjustDimensions();\r\n        this.setSpeed();\r\n\r\n        this.containerEl = document.createElement('div');\r\n        this.containerEl.className = Runner.classes.CONTAINER;\r\n\r\n        // Player canvas container.\r\n        this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,\r\n            this.dimensions.HEIGHT, Runner.classes.PLAYER);\r\n\r\n        this.canvasCtx = this.canvas.getContext('2d');\r\n        this.canvasCtx.fillStyle = '#f7f7f7';\r\n        this.canvasCtx.fill();\r\n        Runner.updateCanvasScaling(this.canvas);\r\n\r\n        // Horizon contains clouds, obstacles and the ground.\r\n        this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,\r\n            this.config.GAP_COEFFICIENT);\r\n\r\n        // Distance meter\r\n        this.distanceMeter = new DistanceMeter(this.canvas,\r\n            this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);\r\n\r\n        // Draw t-rex\r\n        this.tRex = new Trex(this.canvas, this.spriteDef.TREX);\r\n\r\n        // 开始按钮\r\n        this.StartBtn = new StartBtn(this.canvas, this.spriteDef.RESTART,\r\n            this.dimensions);\r\n\r\n        this.outerContainerEl.appendChild(this.containerEl);\r\n\r\n        if (IS_MOBILE) {\r\n            this.createTouchController();\r\n        }\r\n\r\n        this.startListening();\r\n        this.update();\r\n\r\n        window.addEventListener(Runner.events.RESIZE,\r\n            this.debounceResize.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Create the touch controller. A div that covers whole screen.\r\n     */\r\n    createTouchController: function () {\r\n        this.touchController = document.createElement('div');\r\n        this.touchController.className = Runner.classes.TOUCH_CONTROLLER;\r\n    },\r\n\r\n    hideTouchController: function() {\r\n        if (this.touchController) {\r\n            this.touchController.style.height = 0;\r\n        }\r\n    },\r\n\r\n    showTouchController: function() {\r\n        if (this.touchController) {\r\n            this.touchController.style.height = '100%';\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Debounce the resize event.\r\n     */\r\n    debounceResize: function () {\r\n        if (!this.resizeTimerId_) {\r\n            this.resizeTimerId_ =\r\n                setInterval(this.adjustDimensions.bind(this), 250);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adjust game space dimensions on resize.\r\n     */\r\n    adjustDimensions: function () {\r\n        clearInterval(this.resizeTimerId_);\r\n        this.resizeTimerId_ = null;\r\n\r\n        var boxStyles = window.getComputedStyle(this.outerContainerEl);\r\n        var padding = Number(boxStyles.paddingLeft.substr(0,\r\n            boxStyles.paddingLeft.length - 2));\r\n\r\n        this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;\r\n        if (this.isArcadeMode()) {\r\n            this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH);\r\n            if (this.activated) {\r\n                this.setArcadeModeContainerScale();\r\n            }\r\n        }\r\n\r\n        // Redraw the elements back onto the canvas.\r\n        if (this.canvas) {\r\n            this.canvas.width = this.dimensions.WIDTH;\r\n            this.canvas.height = this.dimensions.HEIGHT;\r\n\r\n            Runner.updateCanvasScaling(this.canvas);\r\n\r\n            this.distanceMeter.calcXPos(this.dimensions.WIDTH);\r\n            this.clearCanvas();\r\n            this.horizon.update(0, 0, true);\r\n            this.tRex.update(0);\r\n\r\n            // Outer container and distance meter.\r\n            if (this.playing || this.crashed || this.paused) {\r\n                this.containerEl.style.width = this.dimensions.WIDTH + 'px';\r\n                this.containerEl.style.height = this.dimensions.HEIGHT + 'px';\r\n                this.distanceMeter.update(0, Math.ceil(this.distanceRan));\r\n                this.stop();\r\n            } else {\r\n                this.tRex.draw(0, 0);\r\n            }\r\n\r\n            // Game over panel.\r\n            if (this.crashed && this.gameOverPanel) {\r\n                this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);\r\n                this.gameOverPanel.draw();\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Play the game intro.\r\n     * Canvas container width expands out to the full width.\r\n     */\r\n    playIntro: function () {\r\n        if (!this.activated && !this.crashed) {\r\n            this.playingIntro = true;\r\n            this.tRex.playingIntro = true;\r\n\r\n            /* // CSS animation definition.\r\n            var keyframes = '@-webkit-keyframes intro { ' +\r\n              'from { width:' + Trex.config.WIDTH + 'px }' +\r\n              'to { width: ' + this.dimensions.WIDTH + 'px }' +\r\n              '}';\r\n            document.styleSheets[0].insertRule(keyframes, 0);\r\n  \r\n            this.containerEl.addEventListener(Runner.events.ANIM_END,\r\n              this.startGame.bind(this));\r\n  \r\n            this.containercontainerElEl.style.webkitAnimation = 'intro .4s ease-out 1 both'; */\r\n            this.containerEl.style.width = this.dimensions.WIDTH + 'px';\r\n\r\n            if (this.touchController) {\r\n                this.outerContainerEl.appendChild(this.touchController);\r\n            }\r\n            this.playing = true;\r\n            this.activated = true;\r\n            setTimeout(() => {\r\n                this.startGame();\r\n            }, 400);\r\n\r\n        } else if (this.crashed) {\r\n            this.restart();\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * Update the game status to started.\r\n     */\r\n    startGame: function () {\r\n        if (this.isArcadeMode()) {\r\n            this.setArcadeMode();\r\n        }\r\n        this.runningTime = 0;\r\n        this.playingIntro = false;\r\n        this.tRex.playingIntro = false;\r\n        this.containerEl.style.webkitAnimation = '';\r\n        this.playCount++;\r\n\r\n        // Handle tabbing off the page. Pause the current game.\r\n        document.addEventListener(Runner.events.VISIBILITY,\r\n            this.onVisibilityChange.bind(this));\r\n\r\n        window.addEventListener(Runner.events.BLUR,\r\n            this.onVisibilityChange.bind(this));\r\n\r\n        window.addEventListener(Runner.events.FOCUS,\r\n            this.onVisibilityChange.bind(this));\r\n    },\r\n\r\n    clearCanvas: function () {\r\n        this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,\r\n            this.dimensions.HEIGHT);\r\n    },\r\n\r\n    /**\r\n     * Update the game frame and schedules the next one.\r\n     */\r\n    update: function () {\r\n        this.updatePending = false;\r\n\r\n        var now = getTimeStamp();\r\n        var deltaTime = now - (this.time || now);\r\n        this.time = now;\r\n\r\n        if (this.playing) {\r\n            this.clearCanvas();\r\n\r\n            if (this.tRex.jumping) {\r\n                this.tRex.updateJump(deltaTime);\r\n            }\r\n\r\n            this.runningTime += deltaTime;\r\n            var hasObstacles = this.runningTime > this.config.CLEAR_TIME;\r\n\r\n            // First jump triggers the intro.\r\n            if (this.tRex.jumpCount == 1 && !this.playingIntro) {\r\n                this.playIntro();\r\n            }\r\n\r\n            // The horizon doesn't move until the intro is over.\r\n            if (this.playingIntro) {\r\n                this.horizon.update(0, this.currentSpeed, hasObstacles);\r\n            } else {\r\n                deltaTime = !this.activated ? 0 : deltaTime;\r\n                this.horizon.update(deltaTime, this.currentSpeed, hasObstacles,\r\n                    this.inverted);\r\n            }\r\n\r\n            // Check for collisions.\r\n            var collision = hasObstacles &&\r\n                checkForCollision(this.horizon.obstacles[0], this.tRex);\r\n\r\n            if (!collision) {\r\n                this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;\r\n\r\n                if (this.currentSpeed < this.config.MAX_SPEED) {\r\n                    this.currentSpeed += this.config.ACCELERATION;\r\n                }\r\n            } else {\r\n                this.gameOver();\r\n            }\r\n\r\n            var playAchievementSound = this.distanceMeter.update(deltaTime,\r\n                Math.ceil(this.distanceRan));\r\n\r\n            if (playAchievementSound) {\r\n                this.playSound(this.soundFx.SCORE);\r\n            }\r\n\r\n            // Night mode.\r\n            if (this.invertTimer > this.config.INVERT_FADE_DURATION) {\r\n                this.invertTimer = 0;\r\n                this.invertTrigger = false;\r\n                this.invert();\r\n            } else if (this.invertTimer) {\r\n                this.invertTimer += deltaTime;\r\n            } else {\r\n                var actualDistance =\r\n                    this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));\r\n\r\n                if (actualDistance > 0) {\r\n                    this.invertTrigger = !(actualDistance %\r\n                        this.config.INVERT_DISTANCE);\r\n\r\n                    if (this.invertTrigger && this.invertTimer === 0) {\r\n                        this.invertTimer += deltaTime;\r\n                        this.invert();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.playing || (!this.activated &&\r\n            this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {\r\n            this.tRex.update(deltaTime);\r\n            this.scheduleNextUpdate();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Event handler.\r\n     */\r\n    handleEvent: function (e) {\r\n        return (function (evtType, events) {\r\n            switch (evtType) {\r\n                case events.KEYDOWN:\r\n                case events.TOUCHSTART:\r\n                case events.MOUSEDOWN:\r\n                    this.onKeyDown(e);\r\n                    break;\r\n                case events.KEYUP:\r\n                case events.TOUCHEND:\r\n                case events.MOUSEUP:\r\n                    this.onKeyUp(e);\r\n                    break;\r\n            }\r\n        }.bind(this))(e.type, Runner.events);\r\n    },\r\n\r\n    /**\r\n     * Bind relevant key / mouse / touch listeners.\r\n     */\r\n    startListening: function () {\r\n        // Keys.\r\n        document.addEventListener(Runner.events.KEYDOWN, this);\r\n        document.addEventListener(Runner.events.KEYUP, this);\r\n\r\n        if (IS_MOBILE) {\r\n            // Mobile only touch devices.\r\n            this.touchController.addEventListener(Runner.events.TOUCHSTART, this);\r\n            this.touchController.addEventListener(Runner.events.TOUCHEND, this);\r\n            this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);\r\n            document.addEventListener(Runner.events.TOUCHSTART, this, {\r\n                once: true\r\n            })\r\n        } else {\r\n            // Mouse.\r\n            document.addEventListener(Runner.events.MOUSEDOWN, this);\r\n            document.addEventListener(Runner.events.MOUSEUP, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stopListening: function () {\r\n        document.removeEventListener(Runner.events.KEYDOWN, this);\r\n        document.removeEventListener(Runner.events.KEYUP, this);\r\n\r\n        if (IS_MOBILE) {\r\n            this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);\r\n            this.touchController.removeEventListener(Runner.events.TOUCHEND, this);\r\n            this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);\r\n        } else {\r\n            document.removeEventListener(Runner.events.MOUSEDOWN, this);\r\n            document.removeEventListener(Runner.events.MOUSEUP, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Process keydown.\r\n     * @param {Event} e\r\n     */\r\n    onKeyDown: function (e) {\r\n        // Prevent native page scrolling whilst tapping on mobile.\r\n        if (IS_MOBILE && this.playing) {\r\n            e.preventDefault();\r\n        }\r\n\r\n        if (!this.crashed && !this.paused) {\r\n            if (Runner.keycodes.JUMP[e.keyCode] ||\r\n                e.type == Runner.events.TOUCHSTART) {\r\n                e.preventDefault();\r\n                // Starting the game for the first time.\r\n                if (!this.playing) {\r\n                    this.loadSounds();\r\n                    this.playing = true;\r\n                    this.update();\r\n                    if (window.errorPageController) {\r\n                        errorPageController.trackEasterEgg();\r\n                    }\r\n                }\r\n                // Start jump.\r\n                if (!this.tRex.jumping && !this.tRex.ducking) {\r\n                    this.playSound(this.soundFx.BUTTON_PRESS);\r\n                    this.tRex.startJump(this.currentSpeed);\r\n                }\r\n            } else if (this.playing && Runner.keycodes.DUCK[e.keyCode]) {\r\n                e.preventDefault();\r\n                if (this.tRex.jumping) {\r\n                    // Speed drop, activated only when jump key is not pressed.\r\n                    this.tRex.setSpeedDrop();\r\n                } else if (!this.tRex.jumping && !this.tRex.ducking) {\r\n                    // Duck.\r\n                    this.tRex.setDuck(true);\r\n                }\r\n            }\r\n        } else if (this.crashed && e.type == Runner.events.TOUCHSTART &&\r\n            e.currentTarget == this.containerEl) {\r\n            this.restart();\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * Process key up.\r\n     * @param {Event} e\r\n     */\r\n    onKeyUp: function (e) {\r\n        var keyCode = String(e.keyCode);\r\n        var isjumpKey = Runner.keycodes.JUMP[keyCode] ||\r\n            e.type == Runner.events.TOUCHEND ||\r\n            e.type == Runner.events.MOUSEDOWN;\r\n\r\n        if (this.isRunning() && isjumpKey) {\r\n            this.tRex.endJump();\r\n        } else if (Runner.keycodes.DUCK[keyCode]) {\r\n            this.tRex.speedDrop = false;\r\n            this.tRex.setDuck(false);\r\n        } else if (this.crashed) {\r\n            // Check that enough time has elapsed before allowing jump key to restart.\r\n            var deltaTime = getTimeStamp() - this.time;\r\n\r\n            if (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||\r\n                (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&\r\n                    Runner.keycodes.JUMP[keyCode])) {\r\n                this.restart();\r\n            }\r\n        } else if (this.paused && isjumpKey) {\r\n            // Reset the jump state\r\n            this.tRex.reset();\r\n            this.play();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns whether the event was a left click on canvas.\r\n     * On Windows right click is registered as a click.\r\n     * @param {Event} e\r\n     * @return {boolean}\r\n     */\r\n    isLeftClickOnCanvas: function (e) {\r\n        return e.button != null && e.button < 2 &&\r\n            e.type == Runner.events.MOUSEUP && e.target == this.canvas;\r\n    },\r\n\r\n    /**\r\n     * RequestAnimationFrame wrapper.\r\n     */\r\n    scheduleNextUpdate: function () {\r\n        if (!this.updatePending) {\r\n            this.updatePending = true;\r\n            this.raqId = requestAnimationFrame(this.update.bind(this));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Whether the game is running.\r\n     * @return {boolean}\r\n     */\r\n    isRunning: function () {\r\n        return !!this.raqId;\r\n    },\r\n\r\n    /**\r\n     * Game over state.\r\n     */\r\n    gameOver: function () {\r\n        this.playSound(this.soundFx.HIT);\r\n        vibrate(200);\r\n\r\n        this.stop();\r\n        this.crashed = true;\r\n        this.distanceMeter.achievement = false;\r\n\r\n        this.tRex.update(100, Trex.status.CRASHED);\r\n\r\n        // Game over panel.\r\n        if (!this.gameOverPanel) {\r\n            this.gameOverPanel = new GameOverPanel(this.canvas,\r\n                this.spriteDef.TEXT_SPRITE, this.spriteDef.RESTART,\r\n                this.dimensions);\r\n        } else {\r\n            this.gameOverPanel.draw();\r\n        }\r\n\r\n        // Update the high score.\r\n        if (this.distanceRan > this.highestScore) {\r\n            this.highestScore = Math.ceil(this.distanceRan);\r\n            this.distanceMeter.setHighScore(this.highestScore);\r\n        }\r\n\r\n        // Reset the time clock.\r\n        this.time = getTimeStamp();\r\n\r\n        // 隐藏控制面板\r\n        this.hideTouchController();\r\n        document.title = `我的小恐龙蹦跑了${this.distanceMeter.getActualDistance(this.highestScore)}米，真是太厉害了！`\r\n    },\r\n\r\n    stop: function () {\r\n        this.playing = false;\r\n        this.paused = true;\r\n        cancelAnimationFrame(this.raqId);\r\n        this.raqId = 0;\r\n    },\r\n\r\n    play: function () {\r\n        if (!this.crashed) {\r\n            this.playing = true;\r\n            this.paused = false;\r\n            this.tRex.update(0, Trex.status.RUNNING);\r\n            this.time = getTimeStamp();\r\n            this.update();\r\n        }\r\n    },\r\n\r\n    restart: function () {\r\n        if (!this.raqId) {\r\n            this.playCount++;\r\n            this.runningTime = 0;\r\n            this.playing = true;\r\n            this.paused = false;\r\n            this.crashed = false;\r\n            this.distanceRan = 0;\r\n            this.setSpeed(this.config.SPEED);\r\n            this.time = getTimeStamp();\r\n            this.containerEl.classList.remove(Runner.classes.CRASHED);\r\n            this.clearCanvas();\r\n            this.distanceMeter.reset(this.highestScore);\r\n            this.horizon.reset();\r\n            this.tRex.reset();\r\n            this.playSound(this.soundFx.BUTTON_PRESS);\r\n            this.invert(true);\r\n            this.update();\r\n            this.showTouchController();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Whether the game should go into arcade mode.\r\n     * @return {boolean}\r\n     */\r\n    isArcadeMode: function () {\r\n        return document.title == ARCADE_MODE_URL;\r\n    },\r\n\r\n    /**\r\n     * Hides offline messaging for a fullscreen game only experience.\r\n     */\r\n    setArcadeMode: function () {\r\n        document.body.classList.add(Runner.classes.ARCADE_MODE);\r\n        this.setArcadeModeContainerScale();\r\n    },\r\n\r\n    /**\r\n     * Sets the scaling for arcade mode.\r\n     */\r\n    setArcadeModeContainerScale: function () {\r\n        var windowHeight = window.innerHeight;\r\n        var scaleHeight = windowHeight / this.dimensions.HEIGHT;\r\n        var scaleWidth = window.innerWidth / this.dimensions.WIDTH;\r\n        var scale = Math.max(1, Math.min(scaleHeight, scaleWidth));\r\n        var scaledCanvasHeight = this.dimensions.HEIGHT * scale;\r\n        // Positions the game container at 10% of the available vertical window\r\n        // height minus the game container height.\r\n        var translateY = Math.ceil(Math.max(0, (windowHeight - scaledCanvasHeight -\r\n            Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION) *\r\n            Runner.config.ARCADE_MODE_TOP_POSITION_PERCENT)) *\r\n            window.devicePixelRatio;\r\n        this.containerEl.style.transform = 'scale(' + scale + ') translateY(' +\r\n            translateY + 'px)';\r\n    },\r\n\r\n    /**\r\n     * Pause the game if the tab is not in focus.\r\n     */\r\n    onVisibilityChange: function (e) {\r\n        if (document.hidden || document.webkitHidden || e.type == 'blur' ||\r\n            document.visibilityState != 'visible') {\r\n            this.stop();\r\n        } else if (!this.crashed) {\r\n            this.tRex.reset();\r\n            this.play();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Play a sound.\r\n     * @param {SoundBuffer} soundBuffer\r\n     */\r\n    playSound: function (soundBuffer) {\r\n        if (soundBuffer) {\r\n            var sourceNode = this.audioContext.createBufferSource();\r\n            sourceNode.buffer = soundBuffer;\r\n            sourceNode.connect(this.audioContext.destination);\r\n            sourceNode.start(0);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Inverts the current page / canvas colors.\r\n     * @param {boolean} Whether to reset colors.\r\n     */\r\n    invert: function (reset) {\r\n        if (reset) {\r\n            document.body.classList.toggle(Runner.classes.INVERTED, false);\r\n            this.invertTimer = 0;\r\n            this.inverted = false;\r\n        } else {\r\n            this.inverted = document.body.classList.toggle(Runner.classes.INVERTED,\r\n                this.invertTrigger);\r\n        }\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Updates the canvas size taking into\r\n * account the backing store pixel ratio and\r\n * the device pixel ratio.\r\n *\r\n * See article by Paul Lewis:\r\n * http://www.html5rocks.com/en/tutorials/canvas/hidpi/\r\n *\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {number} opt_width\r\n * @param {number} opt_height\r\n * @return {boolean} Whether the canvas was scaled.\r\n */\r\nRunner.updateCanvasScaling = function (canvas, opt_width, opt_height) {\r\n    var context = canvas.getContext('2d');\r\n\r\n    // Query the various pixel ratios\r\n    var devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;\r\n    var backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;\r\n    var ratio = devicePixelRatio / backingStoreRatio;\r\n\r\n    // Upscale the canvas if the two ratios don't match\r\n    if (devicePixelRatio !== backingStoreRatio) {\r\n        var oldWidth = opt_width || canvas.width;\r\n        var oldHeight = opt_height || canvas.height;\r\n\r\n        canvas.width = oldWidth * ratio;\r\n        canvas.height = oldHeight * ratio;\r\n\r\n        canvas.style.width = oldWidth + 'px';\r\n        canvas.style.height = oldHeight + 'px';\r\n\r\n        // Scale the context to counter the fact that we've manually scaled\r\n        // our canvas element.\r\n        context.scale(ratio, ratio);\r\n        return true;\r\n    } else if (devicePixelRatio == 1) {\r\n        // Reset the canvas width / height. Fixes scaling bug when the page is\r\n        // zoomed and the devicePixelRatio changes accordingly.\r\n        canvas.style.width = canvas.width + 'px';\r\n        canvas.style.height = canvas.height + 'px';\r\n    }\r\n    return false;\r\n};\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\n\r\n\r\n/**\r\n * Vibrate on mobile devices.\r\n * @param {number} duration Duration of the vibration in milliseconds.\r\n */\r\nfunction vibrate(duration) {\r\n    if (IS_MOBILE && window.navigator.vibrate) {\r\n        window.navigator.vibrate(duration);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Create canvas element.\r\n * @param {HTMLElement} container Element to append canvas to.\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {string} opt_classname\r\n * @return {HTMLCanvasElement}\r\n */\r\nfunction createCanvas(container, width, height, opt_classname) {\r\n    var canvas = document.createElement('canvas');\r\n    canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +\r\n        opt_classname : Runner.classes.CANVAS;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    container.appendChild(canvas);\r\n\r\n    return canvas;\r\n}\r\n\r\n\r\n/**\r\n * Decodes the base 64 audio to ArrayBuffer used by Web Audio.\r\n * @param {string} base64String\r\n */\r\nfunction decodeBase64ToArrayBuffer(base64String) {\r\n    var len = (base64String.length / 4) * 3;\r\n    var str = atob(base64String);\r\n    var arrayBuffer = new ArrayBuffer(len);\r\n    var bytes = new Uint8Array(arrayBuffer);\r\n\r\n    for (var i = 0; i < len; i++) {\r\n        bytes[i] = str.charCodeAt(i);\r\n    }\r\n    return bytes.buffer;\r\n}\r\n\r\n\r\n/**\r\n * Return the current timestamp.\r\n * @return {number}\r\n */\r\nfunction getTimeStamp() {\r\n    return IS_IOS ? new Date().getTime() : performance.now();\r\n}\r\n\r\n\r\n//******************************************************************************\r\n\r\n\r\n/**\r\n * Game over panel.\r\n * @param {!HTMLCanvasElement} canvas\r\n * @param {Object} textImgPos\r\n * @param {Object} restartImgPos\r\n * @param {!Object} dimensions Canvas dimensions.\r\n * @constructor\r\n */\r\nfunction GameOverPanel(canvas, textImgPos, restartImgPos, dimensions) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.canvasDimensions = dimensions;\r\n    this.textImgPos = textImgPos;\r\n    this.restartImgPos = restartImgPos;\r\n    this.draw();\r\n};\r\n\r\n\r\n/**\r\n * Dimensions used in the panel.\r\n * @enum {number}\r\n */\r\nGameOverPanel.dimensions = {\r\n    TEXT_X: 0,\r\n    TEXT_Y: 13,\r\n    TEXT_WIDTH: 191,\r\n    TEXT_HEIGHT: 11,\r\n    RESTART_WIDTH: 36,\r\n    RESTART_HEIGHT: 32\r\n};\r\n\r\n\r\nGameOverPanel.prototype = {\r\n    /**\r\n     * Update the panel dimensions.\r\n     * @param {number} width New canvas width.\r\n     * @param {number} opt_height Optional new canvas height.\r\n     */\r\n    updateDimensions: function (width, opt_height) {\r\n        this.canvasDimensions.WIDTH = width;\r\n        if (opt_height) {\r\n            this.canvasDimensions.HEIGHT = opt_height;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Draw the panel.\r\n     */\r\n    draw: function () {\r\n        var dimensions = GameOverPanel.dimensions;\r\n\r\n        var centerX = this.canvasDimensions.WIDTH / 2;\r\n\r\n        // Game over text.\r\n        var textSourceX = dimensions.TEXT_X;\r\n        var textSourceY = dimensions.TEXT_Y;\r\n        var textSourceWidth = dimensions.TEXT_WIDTH;\r\n        var textSourceHeight = dimensions.TEXT_HEIGHT;\r\n\r\n        var textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));\r\n        var textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);\r\n        var textTargetWidth = dimensions.TEXT_WIDTH;\r\n        var textTargetHeight = dimensions.TEXT_HEIGHT;\r\n\r\n        var restartSourceWidth = dimensions.RESTART_WIDTH;\r\n        var restartSourceHeight = dimensions.RESTART_HEIGHT;\r\n        var restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);\r\n        var restartTargetY = this.canvasDimensions.HEIGHT / 2;\r\n\r\n        if (IS_HIDPI) {\r\n            textSourceY *= 2;\r\n            textSourceX *= 2;\r\n            textSourceWidth *= 2;\r\n            textSourceHeight *= 2;\r\n            restartSourceWidth *= 2;\r\n            restartSourceHeight *= 2;\r\n        }\r\n\r\n        textSourceX += this.textImgPos.x;\r\n        textSourceY += this.textImgPos.y;\r\n\r\n        // Game over text from sprite.\r\n        this.canvasCtx.drawImage(Runner.imageSprite,\r\n            textSourceX, textSourceY, textSourceWidth, textSourceHeight,\r\n            textTargetX, textTargetY, textTargetWidth, textTargetHeight);\r\n\r\n        // Restart button.\r\n        this.canvasCtx.drawImage(Runner.imageSprite,\r\n            this.restartImgPos.x, this.restartImgPos.y,\r\n            restartSourceWidth, restartSourceHeight,\r\n            restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,\r\n            dimensions.RESTART_HEIGHT);\r\n    }\r\n};\r\n\r\n\r\n//******************************************************************************\r\n\r\n/**\r\n * Check for a collision.\r\n * @param {!Obstacle} obstacle\r\n * @param {!Trex} tRex T-rex object.\r\n * @param {HTMLCanvasContext} opt_canvasCtx Optional canvas context for drawing\r\n *    collision boxes.\r\n * @return {Array<CollisionBox>}\r\n */\r\nfunction checkForCollision(obstacle, tRex, opt_canvasCtx) {\r\n    var obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;\r\n\r\n    // Adjustments are made to the bounding box as there is a 1 pixel white\r\n    // border around the t-rex and obstacles.\r\n    var tRexBox = new CollisionBox(\r\n        tRex.xPos + 1,\r\n        tRex.yPos + 1,\r\n        tRex.config.WIDTH - 2,\r\n        tRex.config.HEIGHT - 2);\r\n\r\n    var obstacleBox = new CollisionBox(\r\n        obstacle.xPos + 1,\r\n        obstacle.yPos + 1,\r\n        obstacle.typeConfig.width * obstacle.size - 2,\r\n        obstacle.typeConfig.height - 2);\r\n\r\n    // Debug outer box\r\n    if (opt_canvasCtx) {\r\n        drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);\r\n    }\r\n\r\n    // Simple outer bounds check.\r\n    if (boxCompare(tRexBox, obstacleBox)) {\r\n        var collisionBoxes = obstacle.collisionBoxes;\r\n        var tRexCollisionBoxes = tRex.ducking ?\r\n            Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;\r\n\r\n        // Detailed axis aligned box check.\r\n        for (var t = 0; t < tRexCollisionBoxes.length; t++) {\r\n            for (var i = 0; i < collisionBoxes.length; i++) {\r\n                // Adjust the box to actual positions.\r\n                var adjTrexBox =\r\n                    createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);\r\n                var adjObstacleBox =\r\n                    createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);\r\n                var crashed = boxCompare(adjTrexBox, adjObstacleBox);\r\n\r\n                // Draw boxes for debug.\r\n                if (opt_canvasCtx) {\r\n                    drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);\r\n                }\r\n\r\n                if (crashed) {\r\n                    return [adjTrexBox, adjObstacleBox];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n\r\n/**\r\n * Adjust the collision box.\r\n * @param {!CollisionBox} box The original box.\r\n * @param {!CollisionBox} adjustment Adjustment box.\r\n * @return {CollisionBox} The adjusted collision box object.\r\n */\r\nfunction createAdjustedCollisionBox(box, adjustment) {\r\n    return new CollisionBox(\r\n        box.x + adjustment.x,\r\n        box.y + adjustment.y,\r\n        box.width,\r\n        box.height);\r\n};\r\n\r\n\r\n/**\r\n * Draw the collision boxes for debug.\r\n */\r\nfunction drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {\r\n    canvasCtx.save();\r\n    canvasCtx.strokeStyle = '#f00';\r\n    canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);\r\n\r\n    canvasCtx.strokeStyle = '#0f0';\r\n    canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,\r\n        obstacleBox.width, obstacleBox.height);\r\n    canvasCtx.restore();\r\n};\r\n\r\n\r\n/**\r\n * Compare two collision boxes for a collision.\r\n * @param {CollisionBox} tRexBox\r\n * @param {CollisionBox} obstacleBox\r\n * @return {boolean} Whether the boxes intersected.\r\n */\r\nfunction boxCompare(tRexBox, obstacleBox) {\r\n    var crashed = false;\r\n    var tRexBoxX = tRexBox.x;\r\n    var tRexBoxY = tRexBox.y;\r\n\r\n    var obstacleBoxX = obstacleBox.x;\r\n    var obstacleBoxY = obstacleBox.y;\r\n\r\n    // Axis-Aligned Bounding Box method.\r\n    if (tRexBox.x < obstacleBoxX + obstacleBox.width &&\r\n        tRexBox.x + tRexBox.width > obstacleBoxX &&\r\n        tRexBox.y < obstacleBox.y + obstacleBox.height &&\r\n        tRexBox.height + tRexBox.y > obstacleBox.y) {\r\n        crashed = true;\r\n    }\r\n\r\n    return crashed;\r\n};\r\n\r\n\r\n//******************************************************************************\r\n/**\r\n * T-rex game character.\r\n * @param {HTMLCanvas} canvas\r\n * @param {Object} spritePos Positioning within image sprite.\r\n * @constructor\r\n */\r\nfunction Trex(canvas, spritePos) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.spritePos = spritePos;\r\n    this.xPos = 0;\r\n    this.yPos = 0;\r\n    // Position when on the ground.\r\n    this.groundYPos = 0;\r\n    this.currentFrame = 0;\r\n    this.currentAnimFrames = [];\r\n    this.blinkDelay = 0;\r\n    this.blinkCount = 0;\r\n    this.animStartTime = 0;\r\n    this.timer = 0;\r\n    this.msPerFrame = 1000 / FPS;\r\n    this.config = Trex.config;\r\n    // Current status.\r\n    this.status = Trex.status.WAITING;\r\n\r\n    this.jumping = false;\r\n    this.ducking = false;\r\n    this.jumpVelocity = 0;\r\n    this.reachedMinHeight = false;\r\n    this.speedDrop = false;\r\n    this.jumpCount = 0;\r\n    this.jumpspotX = 0;\r\n\r\n    this.init();\r\n};\r\n\r\n\r\n/**\r\n * T-rex player config.\r\n * @enum {number}\r\n */\r\nTrex.config = {\r\n    DROP_VELOCITY: -5,\r\n    GRAVITY: 0.6,\r\n    HEIGHT: 47,\r\n    HEIGHT_DUCK: 25,\r\n    INIITAL_JUMP_VELOCITY: -10,\r\n    INTRO_DURATION: 1500,\r\n    MAX_JUMP_HEIGHT: 30,\r\n    MIN_JUMP_HEIGHT: 30,\r\n    SPEED_DROP_COEFFICIENT: 3,\r\n    SPRITE_WIDTH: 262,\r\n    START_X_POS: 50,\r\n    WIDTH: 44,\r\n    WIDTH_DUCK: 59\r\n};\r\n\r\n\r\n/**\r\n * Used in collision detection.\r\n * @type {Array<CollisionBox>}\r\n */\r\nTrex.collisionBoxes = {\r\n    DUCKING: [\r\n        new CollisionBox(1, 18, 55, 25)\r\n    ],\r\n    RUNNING: [\r\n        new CollisionBox(22, 0, 17, 16),\r\n        new CollisionBox(1, 18, 30, 9),\r\n        new CollisionBox(10, 35, 14, 8),\r\n        new CollisionBox(1, 24, 29, 5),\r\n        new CollisionBox(5, 30, 21, 4),\r\n        new CollisionBox(9, 34, 15, 4)\r\n    ]\r\n};\r\n\r\n\r\n/**\r\n * Animation states.\r\n * @enum {string}\r\n */\r\nTrex.status = {\r\n    CRASHED: 'CRASHED',\r\n    DUCKING: 'DUCKING',\r\n    JUMPING: 'JUMPING',\r\n    RUNNING: 'RUNNING',\r\n    WAITING: 'WAITING'\r\n};\r\n\r\n/**\r\n * Blinking coefficient.\r\n * @const\r\n */\r\nTrex.BLINK_TIMING = 7000;\r\n\r\n\r\n/**\r\n * Animation config for different states.\r\n * @enum {Object}\r\n */\r\nTrex.animFrames = {\r\n    WAITING: {\r\n        frames: [44, 0],\r\n        msPerFrame: 1000 / 3\r\n    },\r\n    RUNNING: {\r\n        frames: [88, 132],\r\n        msPerFrame: 1000 / 12\r\n    },\r\n    CRASHED: {\r\n        frames: [220],\r\n        msPerFrame: 1000 / 60\r\n    },\r\n    JUMPING: {\r\n        frames: [0],\r\n        msPerFrame: 1000 / 60\r\n    },\r\n    DUCKING: {\r\n        frames: [262, 321],\r\n        msPerFrame: 1000 / 8\r\n    }\r\n};\r\n\r\n\r\nTrex.prototype = {\r\n    /**\r\n     * T-rex player initaliser.\r\n     * Sets the t-rex to blink at random intervals.\r\n     */\r\n    init: function () {\r\n        this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -\r\n            Runner.config.BOTTOM_PAD;\r\n        this.yPos = this.groundYPos;\r\n        this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;\r\n\r\n        this.draw(0, 0);\r\n        this.update(0, Trex.status.WAITING);\r\n    },\r\n\r\n    /**\r\n     * Setter for the jump velocity.\r\n     * The approriate drop velocity is also set.\r\n     */\r\n    setJumpVelocity: function (setting) {\r\n        this.config.INIITAL_JUMP_VELOCITY = -setting;\r\n        this.config.DROP_VELOCITY = -setting / 2;\r\n    },\r\n\r\n    /**\r\n     * Set the animation status.\r\n     * @param {!number} deltaTime\r\n     * @param {Trex.status} status Optional status to switch to.\r\n     */\r\n    update: function (deltaTime, opt_status) {\r\n        this.timer += deltaTime;\r\n\r\n        // Update the status.\r\n        if (opt_status) {\r\n            this.status = opt_status;\r\n            this.currentFrame = 0;\r\n            this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;\r\n            this.currentAnimFrames = Trex.animFrames[opt_status].frames;\r\n\r\n            if (opt_status == Trex.status.WAITING) {\r\n                this.animStartTime = getTimeStamp();\r\n                this.setBlinkDelay();\r\n            }\r\n        }\r\n\r\n        // Game intro animation, T-rex moves in from the left.\r\n        if (this.playingIntro && this.xPos < this.config.START_X_POS) {\r\n            this.xPos += Math.round((this.config.START_X_POS /\r\n                this.config.INTRO_DURATION) * deltaTime);\r\n        }\r\n\r\n        if (this.status == Trex.status.WAITING) {\r\n            this.blink(getTimeStamp());\r\n        } else {\r\n            this.draw(this.currentAnimFrames[this.currentFrame], 0);\r\n        }\r\n\r\n        // Update the frame position.\r\n        if (this.timer >= this.msPerFrame) {\r\n            this.currentFrame = this.currentFrame ==\r\n                this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;\r\n            this.timer = 0;\r\n        }\r\n\r\n        // Speed drop becomes duck if the down key is still being pressed.\r\n        if (this.speedDrop && this.yPos == this.groundYPos) {\r\n            this.speedDrop = false;\r\n            this.setDuck(true);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Draw the t-rex to a particular position.\r\n     * @param {number} x\r\n     * @param {number} y\r\n     */\r\n    draw: function (x, y) {\r\n        var sourceX = x;\r\n        var sourceY = y;\r\n        var sourceWidth = this.ducking && this.status != Trex.status.CRASHED ?\r\n            this.config.WIDTH_DUCK : this.config.WIDTH;\r\n        var sourceHeight = this.config.HEIGHT;\r\n\r\n        if (IS_HIDPI) {\r\n            sourceX *= 2;\r\n            sourceY *= 2;\r\n            sourceWidth *= 2;\r\n            sourceHeight *= 2;\r\n        }\r\n\r\n        // Adjustments for sprite sheet position.\r\n        sourceX += this.spritePos.x;\r\n        sourceY += this.spritePos.y;\r\n\r\n        // Ducking.\r\n        if (this.ducking && this.status != Trex.status.CRASHED) {\r\n            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,\r\n                sourceWidth, sourceHeight,\r\n                this.xPos, this.yPos,\r\n                this.config.WIDTH_DUCK, this.config.HEIGHT);\r\n        } else {\r\n            // Crashed whilst ducking. Trex is standing up so needs adjustment.\r\n            if (this.ducking && this.status == Trex.status.CRASHED) {\r\n                this.xPos++;\r\n            }\r\n            // Standing / running\r\n            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,\r\n                sourceWidth, sourceHeight,\r\n                this.xPos, this.yPos,\r\n                this.config.WIDTH, this.config.HEIGHT);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a random time for the blink to happen.\r\n     */\r\n    setBlinkDelay: function () {\r\n        this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);\r\n    },\r\n\r\n    /**\r\n     * Make t-rex blink at random intervals.\r\n     * @param {number} time Current time in milliseconds.\r\n     */\r\n    blink: function (time) {\r\n        var deltaTime = time - this.animStartTime;\r\n\r\n        if (deltaTime >= this.blinkDelay) {\r\n            this.draw(this.currentAnimFrames[this.currentFrame], 0);\r\n\r\n            if (this.currentFrame == 1) {\r\n                // Set new random delay to blink.\r\n                this.setBlinkDelay();\r\n                this.animStartTime = time;\r\n                this.blinkCount++;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Initialise a jump.\r\n     * @param {number} speed\r\n     */\r\n    startJump: function (speed) {\r\n        if (!this.jumping) {\r\n            this.update(0, Trex.status.JUMPING);\r\n            // Tweak the jump velocity based on the speed.\r\n            this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - (speed / 10);\r\n            this.jumping = true;\r\n            this.reachedMinHeight = false;\r\n            this.speedDrop = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Jump is complete, falling down.\r\n     */\r\n    endJump: function () {\r\n        if (this.reachedMinHeight &&\r\n            this.jumpVelocity < this.config.DROP_VELOCITY) {\r\n            this.jumpVelocity = this.config.DROP_VELOCITY;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Update frame for a jump.\r\n     * @param {number} deltaTime\r\n     * @param {number} speed\r\n     */\r\n    updateJump: function (deltaTime, speed) {\r\n        var msPerFrame = Trex.animFrames[this.status].msPerFrame;\r\n        var framesElapsed = deltaTime / msPerFrame;\r\n\r\n        // Speed drop makes Trex fall faster.\r\n        if (this.speedDrop) {\r\n            this.yPos += Math.round(this.jumpVelocity *\r\n                this.config.SPEED_DROP_COEFFICIENT * framesElapsed);\r\n        } else {\r\n            this.yPos += Math.round(this.jumpVelocity * framesElapsed);\r\n        }\r\n\r\n        this.jumpVelocity += this.config.GRAVITY * framesElapsed;\r\n\r\n        // Minimum height has been reached.\r\n        if (this.yPos < this.minJumpHeight || this.speedDrop) {\r\n            this.reachedMinHeight = true;\r\n        }\r\n\r\n        // Reached max height\r\n        if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) {\r\n            this.endJump();\r\n        }\r\n\r\n        // Back down at ground level. Jump completed.\r\n        if (this.yPos > this.groundYPos) {\r\n            this.reset();\r\n            this.jumpCount++;\r\n        }\r\n\r\n        this.update(deltaTime);\r\n    },\r\n\r\n    /**\r\n     * Set the speed drop. Immediately cancels the current jump.\r\n     */\r\n    setSpeedDrop: function () {\r\n        this.speedDrop = true;\r\n        this.jumpVelocity = 1;\r\n    },\r\n\r\n    /**\r\n     * @param {boolean} isDucking.\r\n     */\r\n    setDuck: function (isDucking) {\r\n        if (isDucking && this.status != Trex.status.DUCKING) {\r\n            this.update(0, Trex.status.DUCKING);\r\n            this.ducking = true;\r\n        } else if (this.status == Trex.status.DUCKING) {\r\n            this.update(0, Trex.status.RUNNING);\r\n            this.ducking = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Reset the t-rex to running at start of game.\r\n     */\r\n    reset: function () {\r\n        this.yPos = this.groundYPos;\r\n        this.jumpVelocity = 0;\r\n        this.jumping = false;\r\n        this.ducking = false;\r\n        this.update(0, Trex.status.RUNNING);\r\n        this.midair = false;\r\n        this.speedDrop = false;\r\n        this.jumpCount = 0;\r\n    }\r\n};\r\n\r\n\r\n//******************************************************************************\r\n\r\n/**\r\n * Handles displaying the distance meter.\r\n * @param {!HTMLCanvasElement} canvas\r\n * @param {Object} spritePos Image position in sprite.\r\n * @param {number} canvasWidth\r\n * @constructor\r\n */\r\nfunction DistanceMeter(canvas, spritePos, canvasWidth) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.image = Runner.imageSprite;\r\n    this.spritePos = spritePos;\r\n    this.x = 0;\r\n    this.y = 5;\r\n\r\n    this.currentDistance = 0;\r\n    this.maxScore = 0;\r\n    this.highScore = 0;\r\n    this.container = null;\r\n\r\n    this.digits = [];\r\n    this.achievement = false;\r\n    this.defaultString = '';\r\n    this.flashTimer = 0;\r\n    this.flashIterations = 0;\r\n    this.invertTrigger = false;\r\n\r\n    this.config = DistanceMeter.config;\r\n    this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;\r\n    this.init(canvasWidth);\r\n};\r\n\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nDistanceMeter.dimensions = {\r\n    WIDTH: 10,\r\n    HEIGHT: 13,\r\n    DEST_WIDTH: 11\r\n};\r\n\r\n\r\n/**\r\n * Y positioning of the digits in the sprite sheet.\r\n * X position is always 0.\r\n * @type {Array<number>}\r\n */\r\nDistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];\r\n\r\n\r\n/**\r\n * Distance meter config.\r\n * @enum {number}\r\n */\r\nDistanceMeter.config = {\r\n    // Number of digits.\r\n    MAX_DISTANCE_UNITS: 5,\r\n\r\n    // Distance that causes achievement animation.\r\n    ACHIEVEMENT_DISTANCE: 100,\r\n\r\n    // Used for conversion from pixel distance to a scaled unit.\r\n    COEFFICIENT: 0.025,\r\n\r\n    // Flash duration in milliseconds.\r\n    FLASH_DURATION: 1000 / 4,\r\n\r\n    // Flash iterations for achievement animation.\r\n    FLASH_ITERATIONS: 3\r\n};\r\n\r\n\r\nDistanceMeter.prototype = {\r\n    /**\r\n     * Initialise the distance meter to '00000'.\r\n     * @param {number} width Canvas width in px.\r\n     */\r\n    init: function (width) {\r\n        var maxDistanceStr = '';\r\n\r\n        this.calcXPos(width);\r\n        this.maxScore = this.maxScoreUnits;\r\n        for (var i = 0; i < this.maxScoreUnits; i++) {\r\n            this.draw(i, 0);\r\n            this.defaultString += '0';\r\n            maxDistanceStr += '9';\r\n        }\r\n\r\n        this.maxScore = parseInt(maxDistanceStr);\r\n    },\r\n\r\n    /**\r\n     * Calculate the xPos in the canvas.\r\n     * @param {number} canvasWidth\r\n     */\r\n    calcXPos: function (canvasWidth) {\r\n        this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *\r\n            (this.maxScoreUnits + 1));\r\n    },\r\n\r\n    /**\r\n     * Draw a digit to canvas.\r\n     * @param {number} digitPos Position of the digit.\r\n     * @param {number} value Digit value 0-9.\r\n     * @param {boolean} opt_highScore Whether drawing the high score.\r\n     */\r\n    draw: function (digitPos, value, opt_highScore) {\r\n        var sourceWidth = DistanceMeter.dimensions.WIDTH;\r\n        var sourceHeight = DistanceMeter.dimensions.HEIGHT;\r\n        var sourceX = DistanceMeter.dimensions.WIDTH * value;\r\n        var sourceY = 0;\r\n\r\n        var targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;\r\n        var targetY = this.y;\r\n        var targetWidth = DistanceMeter.dimensions.WIDTH;\r\n        var targetHeight = DistanceMeter.dimensions.HEIGHT;\r\n\r\n        // For high DPI we 2x source values.\r\n        if (IS_HIDPI) {\r\n            sourceWidth *= 2;\r\n            sourceHeight *= 2;\r\n            sourceX *= 2;\r\n        }\r\n\r\n        sourceX += this.spritePos.x;\r\n        sourceY += this.spritePos.y;\r\n\r\n        this.canvasCtx.save();\r\n\r\n        if (opt_highScore) {\r\n            // Left of the current score.\r\n            var highScoreX = this.x - (this.maxScoreUnits * 2) *\r\n                DistanceMeter.dimensions.WIDTH;\r\n            this.canvasCtx.translate(highScoreX, this.y);\r\n        } else {\r\n            this.canvasCtx.translate(this.x, this.y);\r\n        }\r\n\r\n        this.canvasCtx.drawImage(this.image, sourceX, sourceY,\r\n            sourceWidth, sourceHeight,\r\n            targetX, targetY,\r\n            targetWidth, targetHeight\r\n        );\r\n\r\n        this.canvasCtx.restore();\r\n    },\r\n\r\n    /**\r\n     * Covert pixel distance to a 'real' distance.\r\n     * @param {number} distance Pixel distance ran.\r\n     * @return {number} The 'real' distance ran.\r\n     */\r\n    getActualDistance: function (distance) {\r\n        return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;\r\n    },\r\n\r\n    /**\r\n     * Update the distance meter.\r\n     * @param {number} distance\r\n     * @param {number} deltaTime\r\n     * @return {boolean} Whether the acheivement sound fx should be played.\r\n     */\r\n    update: function (deltaTime, distance) {\r\n        var paint = true;\r\n        var playSound = false;\r\n\r\n        if (!this.achievement) {\r\n            distance = this.getActualDistance(distance);\r\n            // Score has gone beyond the initial digit count.\r\n            if (distance > this.maxScore && this.maxScoreUnits ==\r\n                this.config.MAX_DISTANCE_UNITS) {\r\n                this.maxScoreUnits++;\r\n                this.maxScore = parseInt(this.maxScore + '9');\r\n            } else {\r\n                this.distance = 0;\r\n            }\r\n\r\n            if (distance > 0) {\r\n                // Acheivement unlocked\r\n                if (distance % this.config.ACHIEVEMENT_DISTANCE == 0) {\r\n                    // Flash score and play sound.\r\n                    this.achievement = true;\r\n                    this.flashTimer = 0;\r\n                    playSound = true;\r\n                }\r\n\r\n                // Create a string representation of the distance with leading 0.\r\n                var distanceStr = (this.defaultString +\r\n                    distance).substr(-this.maxScoreUnits);\r\n                this.digits = distanceStr.split('');\r\n            } else {\r\n                this.digits = this.defaultString.split('');\r\n            }\r\n        } else {\r\n            // Control flashing of the score on reaching acheivement.\r\n            if (this.flashIterations <= this.config.FLASH_ITERATIONS) {\r\n                this.flashTimer += deltaTime;\r\n\r\n                if (this.flashTimer < this.config.FLASH_DURATION) {\r\n                    paint = false;\r\n                } else if (this.flashTimer >\r\n                    this.config.FLASH_DURATION * 2) {\r\n                    this.flashTimer = 0;\r\n                    this.flashIterations++;\r\n                }\r\n            } else {\r\n                this.achievement = false;\r\n                this.flashIterations = 0;\r\n                this.flashTimer = 0;\r\n            }\r\n        }\r\n\r\n        // Draw the digits if not flashing.\r\n        if (paint) {\r\n            for (var i = this.digits.length - 1; i >= 0; i--) {\r\n                this.draw(i, parseInt(this.digits[i]));\r\n            }\r\n        }\r\n\r\n        this.drawHighScore();\r\n        return playSound;\r\n    },\r\n\r\n    /**\r\n     * Draw the high score.\r\n     */\r\n    drawHighScore: function () {\r\n        this.canvasCtx.save();\r\n        this.canvasCtx.globalAlpha = .8;\r\n        for (var i = this.highScore.length - 1; i >= 0; i--) {\r\n            this.draw(i, parseInt(this.highScore[i], 10), true);\r\n        }\r\n        this.canvasCtx.restore();\r\n    },\r\n\r\n    /**\r\n     * Set the highscore as a array string.\r\n     * Position of char in the sprite: H - 10, I - 11.\r\n     * @param {number} distance Distance ran in pixels.\r\n     */\r\n    setHighScore: function (distance) {\r\n        distance = this.getActualDistance(distance);\r\n        var highScoreStr = (this.defaultString +\r\n            distance).substr(-this.maxScoreUnits);\r\n\r\n        this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));\r\n    },\r\n\r\n    /**\r\n     * Reset the distance meter back to '00000'.\r\n     */\r\n    reset: function () {\r\n        this.update(0);\r\n        this.achievement = false;\r\n    }\r\n};\r\n\r\n\r\n\r\n//******************************************************************************\r\n\r\nmodule.exports = Runner;","var Runner = require('./runner');\r\n\r\nwindow.onload = function () {\r\n\tvar runner = new Runner('#game-containter');\r\n}"],"sourceRoot":""}