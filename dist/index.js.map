{"version":3,"sources":["webpack:///webpack/bootstrap 54ceee6f694ef2ae0dbd","webpack:///./src/index.js","webpack:///./src/runner.js","webpack:///./src/Horizon.js","webpack:///./src/Cloud.js","webpack:///./src/utils.js","webpack:///./src/HorizonLine.js","webpack:///./src/NightMode.js","webpack:///./src/Obstacle.js","webpack:///./src/CollisionBox.js","webpack:///./src/StartBtn.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;;AAEA;AACA;AACA,C;;;;;;;ACHA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B;AAC3B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,uBAAuB,eAAe;AACtC,gBAAgB,cAAc;AAC9B,kBAAkB,cAAc;AAChC,eAAe,eAAe;AAC9B,sBAAsB,eAAe;AACrC,kBAAkB,aAAa;AAC/B,sBAAsB,eAAe;AACrC,eAAe,eAAe;AAC9B,eAAe;AACf,KAAK;AACL;AACA,uBAAuB,eAAe;AACtC,uBAAuB,eAAe;AACtC,gBAAgB,eAAe;AAC/B,kBAAkB,eAAe;AACjC,eAAe,eAAe;AAC9B,sBAAsB,eAAe;AACrC,kBAAkB,aAAa;AAC/B,sBAAsB,gBAAgB;AACtC,eAAe,gBAAgB;AAC/B,eAAe;AACf;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,UAAU;AACrB,cAAc,UAAU;AACxB;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD,qBAAqB,oCAAoC;AACzD,mBAAmB,yCAAyC;AAC5D,gBAAgB;AAChB;;AAEA;AACA;;AAEA,4FAA4F;AAC5F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,MAAM;AACjB,WAAW,kBAAkB;AAC7B;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,+BAA+B;AACtD,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA,wB;;;;;;ACp1DA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA,2BAA2B,2BAA2B;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;ACjOA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;AClGA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe;AACf;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,C;;;;;;ACZA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;;AClIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,uBAAuB,gCAAgC;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2B;;;;;;AC/JA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0B;;;;;;AClQA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8B;;;;;;ACdA;AACA;AACA;AACA;AACA;;AAEA,0B","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 54ceee6f694ef2ae0dbd","var Runner = require('./runner');\r\n\r\nwindow.onload = function () {\r\n\tvar runner = new Runner('#game-containter');\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0","\r\nvar Horizon = require('./Horizon'),\r\n    utils = require('./utils');\r\n\r\nvar CollisionBox = require('./CollisionBox'),\r\n    StartBtn = require('./StartBtn');\r\n\r\n/**\r\n * T-Rex runner.\r\n * @param {string} outerContainerId Outer containing element id.\r\n * @param {Object} opt_config\r\n * @constructor\r\n * @export\r\n */\r\nfunction Runner(outerContainerId, opt_config) {\r\n    // Singleton\r\n    if (Runner.instance_) {\r\n        return Runner.instance_;\r\n    }\r\n    Runner.instance_ = this;\r\n\r\n    this.outerContainerEl = document.querySelector(outerContainerId);\r\n    this.containerEl = null;\r\n    this.snackbarEl = null;\r\n\r\n    this.config = opt_config || Runner.config;\r\n    // Logical dimensions of the container.\r\n    this.dimensions = Runner.defaultDimensions;\r\n\r\n    this.canvas = null;\r\n    this.canvasCtx = null;\r\n\r\n    this.tRex = null;\r\n\r\n    this.distanceMeter = null;\r\n    this.distanceRan = 0;\r\n\r\n    this.highestScore = 0;\r\n\r\n    this.time = 0;\r\n    this.runningTime = 0;\r\n    this.msPerFrame = 1000 / FPS;\r\n    this.currentSpeed = this.config.SPEED;\r\n\r\n    this.obstacles = [];\r\n\r\n    this.activated = false; // Whether the easter egg has been activated.\r\n    this.playing = false; // Whether the game is currently in play state.\r\n    this.crashed = false;\r\n    this.paused = false;\r\n    this.inverted = false;\r\n    this.invertTimer = 0;\r\n    this.resizeTimerId_ = null;\r\n\r\n    this.playCount = 0;\r\n\r\n    // Sound FX.\r\n    this.audioBuffer = null;\r\n    this.soundFx = {};\r\n\r\n    // Global web audio context for playing sounds.\r\n    this.audioContext = null;\r\n\r\n    // Images.\r\n    this.images = {};\r\n    this.imagesLoaded = 0;\r\n\r\n    this.loadImages();\r\n}\r\n\r\n\r\nwindow['Runner'] = Runner;\r\n\r\n/**\r\n * Default game width.\r\n * @const\r\n */\r\nvar DEFAULT_WIDTH = 600;\r\n\r\n/**\r\n * Frames per second.\r\n * @const\r\n */\r\nvar FPS = utils.FPS;\r\n\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\n\r\n/** @const */\r\nvar IS_IOS = /iPad|iPhone|iPod/.test(window.navigator.platform);\r\n\r\n/** @const */\r\nvar IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS || true;\r\n\r\n/** @const */\r\nvar IS_TOUCH_ENABLED = 'ontouchstart' in window;\r\n\r\n/** @const */\r\nvar ARCADE_MODE_URL = 'chrome://dino/';\r\n\r\n/**\r\n * Default game configuration.\r\n * @enum {number}\r\n */\r\nRunner.config = {\r\n    ACCELERATION: 0.001,\r\n    BG_CLOUD_SPEED: 0.2,\r\n    BOTTOM_PAD: 10,\r\n    CLEAR_TIME: 3000,\r\n    CLOUD_FREQUENCY: 0.5,\r\n    GAMEOVER_CLEAR_TIME: 750,\r\n    GAP_COEFFICIENT: 0.6,\r\n    GRAVITY: 0.6,\r\n    INITIAL_JUMP_VELOCITY: 12,\r\n    INVERT_FADE_DURATION: 12000,\r\n    INVERT_DISTANCE: 700,\r\n    MAX_BLINK_COUNT: 3,\r\n    MAX_CLOUDS: 6,\r\n    MAX_OBSTACLE_LENGTH: 3,\r\n    MAX_OBSTACLE_DUPLICATION: 2,\r\n    MAX_SPEED: 13,\r\n    MIN_JUMP_HEIGHT: 35,\r\n    MOBILE_SPEED_COEFFICIENT: 1.2,\r\n    RESOURCE_TEMPLATE_ID: 'audio-resources',\r\n    SPEED: 6,\r\n    SPEED_DROP_COEFFICIENT: 3,\r\n    ARCADE_MODE_INITIAL_TOP_POSITION: 35,\r\n    ARCADE_MODE_TOP_POSITION_PERCENT: 0.1\r\n};\r\n\r\n\r\n/**\r\n * Default dimensions.\r\n * @enum {string}\r\n */\r\nRunner.defaultDimensions = {\r\n    WIDTH: DEFAULT_WIDTH,\r\n    HEIGHT: 150\r\n};\r\n\r\n\r\n/**\r\n * CSS class names.\r\n * @enum {string}\r\n */\r\nRunner.classes = {\r\n    ARCADE_MODE: 'arcade-mode',\r\n    CANVAS: 'runner-canvas',\r\n    CONTAINER: 'runner-container',\r\n    CRASHED: 'crashed',\r\n    ICON: 'icon-offline',\r\n    INVERTED: 'inverted',\r\n    SNACKBAR: 'snackbar',\r\n    SNACKBAR_SHOW: 'snackbar-show',\r\n    TOUCH_CONTROLLER: 'controller'\r\n};\r\n\r\n\r\n/**\r\n * Sprite definition layout of the spritesheet.\r\n * @enum {Object}\r\n */\r\nRunner.spriteDefinition = {\r\n    LDPI: {\r\n        CACTUS_LARGE: { x: 332, y: 2 },\r\n        CACTUS_SMALL: { x: 228, y: 2 },\r\n        CLOUD: { x: 86, y: 2 },\r\n        HORIZON: { x: 2, y: 54 },\r\n        MOON: { x: 484, y: 2 },\r\n        PTERODACTYL: { x: 134, y: 2 },\r\n        RESTART: { x: 2, y: 2 },\r\n        TEXT_SPRITE: { x: 655, y: 2 },\r\n        TREX: { x: 848, y: 2 },\r\n        STAR: { x: 645, y: 2 }\r\n    },\r\n    HDPI: {\r\n        CACTUS_LARGE: { x: 652, y: 2 },\r\n        CACTUS_SMALL: { x: 446, y: 2 },\r\n        CLOUD: { x: 166, y: 2 },\r\n        HORIZON: { x: 2, y: 104 },\r\n        MOON: { x: 954, y: 2 },\r\n        PTERODACTYL: { x: 260, y: 2 },\r\n        RESTART: { x: 2, y: 2 },\r\n        TEXT_SPRITE: { x: 1294, y: 2 },\r\n        TREX: { x: 1678, y: 2 },\r\n        STAR: { x: 1276, y: 2 }\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Sound FX. Reference to the ID of the audio tag on interstitial page.\r\n * @enum {string}\r\n */\r\nRunner.sounds = {\r\n    BUTTON_PRESS: 'offline-sound-press',\r\n    HIT: 'offline-sound-hit',\r\n    SCORE: 'offline-sound-reached'\r\n};\r\n\r\n\r\n/**\r\n * Key code mapping.\r\n * @enum {Object}\r\n */\r\nRunner.keycodes = {\r\n    JUMP: { '38': 1, '32': 1 },  // Up, spacebar\r\n    DUCK: { '40': 1 },  // Down\r\n    RESTART: { '13': 1 }  // Enter\r\n};\r\n\r\n\r\n/**\r\n * Runner event names.\r\n * @enum {string}\r\n */\r\nRunner.events = {\r\n    ANIM_END: 'webkitAnimationEnd',\r\n    CLICK: 'click',\r\n    KEYDOWN: 'keydown',\r\n    KEYUP: 'keyup',\r\n    MOUSEDOWN: 'mousedown',\r\n    MOUSEUP: 'mouseup',\r\n    RESIZE: 'resize',\r\n    TOUCHEND: 'touchend',\r\n    TOUCHSTART: 'touchstart',\r\n    VISIBILITY: 'visibilitychange',\r\n    BLUR: 'blur',\r\n    FOCUS: 'focus',\r\n    LOAD: 'load'\r\n};\r\n\r\nRunner.prototype = {\r\n    /**\r\n     * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.\r\n     * @return {boolean}\r\n     */\r\n    isDisabled: function () {\r\n        return loadTimeData && loadTimeData.valueExists('disabledEasterEgg');\r\n    },\r\n\r\n    /**\r\n     * For disabled instances, set up a snackbar with the disabled message.\r\n     */\r\n    setupDisabledRunner: function () {\r\n        this.containerEl = document.createElement('div');\r\n        this.containerEl.className = Runner.classes.SNACKBAR;\r\n        this.containerEl.textContent = loadTimeData.getValue('disabledEasterEgg');\r\n        this.outerContainerEl.appendChild(this.containerEl);\r\n\r\n        // Show notification when the activation key is pressed.\r\n        document.addEventListener(Runner.events.KEYDOWN, function (e) {\r\n            if (Runner.keycodes.JUMP[e.keyCode]) {\r\n                this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW);\r\n                document.querySelector('.icon').classList.add('icon-disabled');\r\n            }\r\n        }.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Setting individual settings for debugging.\r\n     * @param {string} setting\r\n     * @param {*} value\r\n     */\r\n    updateConfigSetting: function (setting, value) {\r\n        if (setting in this.config && value != undefined) {\r\n            this.config[setting] = value;\r\n\r\n            switch (setting) {\r\n                case 'GRAVITY':\r\n                case 'MIN_JUMP_HEIGHT':\r\n                case 'SPEED_DROP_COEFFICIENT':\r\n                    this.tRex.config[setting] = value;\r\n                    break;\r\n                case 'INITIAL_JUMP_VELOCITY':\r\n                    this.tRex.setJumpVelocity(value);\r\n                    break;\r\n                case 'SPEED':\r\n                    this.setSpeed(value);\r\n                    break;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Cache the appropriate image sprite from the page and get the sprite sheet\r\n     * definition.\r\n     */\r\n    loadImages: function () {\r\n        if (IS_HIDPI) {\r\n            Runner.imageSprite = document.getElementById('offline-resources-2x');\r\n            this.spriteDef = Runner.spriteDefinition.HDPI;\r\n        } else {\r\n            Runner.imageSprite = document.getElementById('offline-resources-1x');\r\n            this.spriteDef = Runner.spriteDefinition.LDPI;\r\n        }\r\n\r\n        if (Runner.imageSprite.complete) {\r\n            this.init();\r\n        } else {\r\n            // If the images are not yet loaded, add a listener.\r\n            Runner.imageSprite.addEventListener(Runner.events.LOAD,\r\n                this.init.bind(this));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Load and decode base 64 encoded sounds.\r\n     */\r\n    loadSounds: function () {\r\n        if (!IS_IOS) {\r\n            this.audioContext = new AudioContext();\r\n\r\n            var resourceTemplate =\r\n                document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;\r\n\r\n            for (var sound in Runner.sounds) {\r\n                var soundSrc =\r\n                    resourceTemplate.getElementById(Runner.sounds[sound]).src;\r\n                soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);\r\n                var buffer = decodeBase64ToArrayBuffer(soundSrc);\r\n\r\n                // Async, so no guarantee of order in array.\r\n                this.audioContext.decodeAudioData(buffer, function (index, audioData) {\r\n                    this.soundFx[index] = audioData;\r\n                }.bind(this, sound));\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the game speed. Adjust the speed accordingly if on a smaller screen.\r\n     * @param {number} opt_speed\r\n     */\r\n    setSpeed: function (opt_speed) {\r\n        var speed = opt_speed || this.currentSpeed;\r\n\r\n        // Reduce the speed on smaller mobile screens.\r\n        if (this.dimensions.WIDTH < DEFAULT_WIDTH) {\r\n            var mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH *\r\n                this.config.MOBILE_SPEED_COEFFICIENT;\r\n            this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;\r\n        } else if (opt_speed) {\r\n            this.currentSpeed = opt_speed;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Game initialiser.\r\n     */\r\n    init: function () {\r\n        // Hide the static icon.\r\n        /*  document.querySelector('.' + Runner.classes.ICON).style.visibility =\r\n           'hidden'; */\r\n\r\n        this.adjustDimensions();\r\n        this.setSpeed();\r\n\r\n        this.containerEl = document.createElement('div');\r\n        this.containerEl.className = Runner.classes.CONTAINER;\r\n\r\n        // Player canvas container.\r\n        this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,\r\n            this.dimensions.HEIGHT, Runner.classes.PLAYER);\r\n\r\n        this.canvasCtx = this.canvas.getContext('2d');\r\n        this.canvasCtx.fillStyle = '#f7f7f7';\r\n        this.canvasCtx.fill();\r\n        Runner.updateCanvasScaling(this.canvas);\r\n\r\n        // Horizon contains clouds, obstacles and the ground.\r\n        this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,\r\n            this.config.GAP_COEFFICIENT);\r\n\r\n        // Distance meter\r\n        this.distanceMeter = new DistanceMeter(this.canvas,\r\n            this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);\r\n\r\n        // Draw t-rex\r\n        this.tRex = new Trex(this.canvas, this.spriteDef.TREX);\r\n\r\n        // 开始按钮\r\n        this.StartBtn = new StartBtn(this.canvas);\r\n\r\n        this.outerContainerEl.appendChild(this.containerEl);\r\n\r\n        if (IS_MOBILE) {\r\n            this.createTouchController();\r\n        }\r\n\r\n        this.startListening();\r\n        this.update();\r\n\r\n        window.addEventListener(Runner.events.RESIZE,\r\n            this.debounceResize.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Create the touch controller. A div that covers whole screen.\r\n     */\r\n    createTouchController: function () {\r\n        this.touchController = document.createElement('div');\r\n        this.touchController.className = Runner.classes.TOUCH_CONTROLLER;\r\n    },\r\n\r\n    /**\r\n     * Debounce the resize event.\r\n     */\r\n    debounceResize: function () {\r\n        if (!this.resizeTimerId_) {\r\n            this.resizeTimerId_ =\r\n                setInterval(this.adjustDimensions.bind(this), 250);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adjust game space dimensions on resize.\r\n     */\r\n    adjustDimensions: function () {\r\n        clearInterval(this.resizeTimerId_);\r\n        this.resizeTimerId_ = null;\r\n\r\n        var boxStyles = window.getComputedStyle(this.outerContainerEl);\r\n        var padding = Number(boxStyles.paddingLeft.substr(0,\r\n            boxStyles.paddingLeft.length - 2));\r\n\r\n        this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;\r\n        if (this.isArcadeMode()) {\r\n            this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH);\r\n            if (this.activated) {\r\n                this.setArcadeModeContainerScale();\r\n            }\r\n        }\r\n\r\n        // Redraw the elements back onto the canvas.\r\n        if (this.canvas) {\r\n            this.canvas.width = this.dimensions.WIDTH;\r\n            this.canvas.height = this.dimensions.HEIGHT;\r\n\r\n            Runner.updateCanvasScaling(this.canvas);\r\n\r\n            this.distanceMeter.calcXPos(this.dimensions.WIDTH);\r\n            this.clearCanvas();\r\n            this.horizon.update(0, 0, true);\r\n            this.tRex.update(0);\r\n\r\n            // Outer container and distance meter.\r\n            if (this.playing || this.crashed || this.paused) {\r\n                this.containerEl.style.width = this.dimensions.WIDTH + 'px';\r\n                this.containerEl.style.height = this.dimensions.HEIGHT + 'px';\r\n                this.distanceMeter.update(0, Math.ceil(this.distanceRan));\r\n                this.stop();\r\n            } else {\r\n                this.tRex.draw(0, 0);\r\n            }\r\n\r\n            // Game over panel.\r\n            if (this.crashed && this.gameOverPanel) {\r\n                this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);\r\n                this.gameOverPanel.draw();\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Play the game intro.\r\n     * Canvas container width expands out to the full width.\r\n     */\r\n    playIntro: function () {\r\n        if (!this.activated && !this.crashed) {\r\n            this.playingIntro = true;\r\n            this.tRex.playingIntro = true;\r\n\r\n            /* // CSS animation definition.\r\n            var keyframes = '@-webkit-keyframes intro { ' +\r\n              'from { width:' + Trex.config.WIDTH + 'px }' +\r\n              'to { width: ' + this.dimensions.WIDTH + 'px }' +\r\n              '}';\r\n            document.styleSheets[0].insertRule(keyframes, 0);\r\n  \r\n            this.containerEl.addEventListener(Runner.events.ANIM_END,\r\n              this.startGame.bind(this));\r\n  \r\n            this.containercontainerElEl.style.webkitAnimation = 'intro .4s ease-out 1 both'; */\r\n            this.containerEl.style.width = this.dimensions.WIDTH + 'px';\r\n\r\n            if (this.touchController) {\r\n                this.outerContainerEl.appendChild(this.touchController);\r\n            }\r\n            this.playing = true;\r\n            this.activated = true;\r\n            setTimeout(() => {\r\n                this.startGame();\r\n            }, 400);\r\n\r\n        } else if (this.crashed) {\r\n            this.restart();\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * Update the game status to started.\r\n     */\r\n    startGame: function () {\r\n        if (this.isArcadeMode()) {\r\n            this.setArcadeMode();\r\n        }\r\n        this.runningTime = 0;\r\n        this.playingIntro = false;\r\n        this.tRex.playingIntro = false;\r\n        this.containerEl.style.webkitAnimation = '';\r\n        this.playCount++;\r\n\r\n        // Handle tabbing off the page. Pause the current game.\r\n        document.addEventListener(Runner.events.VISIBILITY,\r\n            this.onVisibilityChange.bind(this));\r\n\r\n        window.addEventListener(Runner.events.BLUR,\r\n            this.onVisibilityChange.bind(this));\r\n\r\n        window.addEventListener(Runner.events.FOCUS,\r\n            this.onVisibilityChange.bind(this));\r\n    },\r\n\r\n    clearCanvas: function () {\r\n        this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,\r\n            this.dimensions.HEIGHT);\r\n    },\r\n\r\n    /**\r\n     * Update the game frame and schedules the next one.\r\n     */\r\n    update: function () {\r\n        this.updatePending = false;\r\n\r\n        var now = getTimeStamp();\r\n        var deltaTime = now - (this.time || now);\r\n        this.time = now;\r\n\r\n        if (this.playing) {\r\n            this.clearCanvas();\r\n\r\n            if (this.tRex.jumping) {\r\n                this.tRex.updateJump(deltaTime);\r\n            }\r\n\r\n            this.runningTime += deltaTime;\r\n            var hasObstacles = this.runningTime > this.config.CLEAR_TIME;\r\n\r\n            // First jump triggers the intro.\r\n            if (this.tRex.jumpCount == 1 && !this.playingIntro) {\r\n                this.playIntro();\r\n            }\r\n\r\n            // The horizon doesn't move until the intro is over.\r\n            if (this.playingIntro) {\r\n                this.horizon.update(0, this.currentSpeed, hasObstacles);\r\n            } else {\r\n                deltaTime = !this.activated ? 0 : deltaTime;\r\n                this.horizon.update(deltaTime, this.currentSpeed, hasObstacles,\r\n                    this.inverted);\r\n            }\r\n\r\n            // Check for collisions.\r\n            var collision = hasObstacles &&\r\n                checkForCollision(this.horizon.obstacles[0], this.tRex);\r\n\r\n            if (!collision) {\r\n                this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;\r\n\r\n                if (this.currentSpeed < this.config.MAX_SPEED) {\r\n                    this.currentSpeed += this.config.ACCELERATION;\r\n                }\r\n            } else {\r\n                this.gameOver();\r\n            }\r\n\r\n            var playAchievementSound = this.distanceMeter.update(deltaTime,\r\n                Math.ceil(this.distanceRan));\r\n\r\n            if (playAchievementSound) {\r\n                this.playSound(this.soundFx.SCORE);\r\n            }\r\n\r\n            // Night mode.\r\n            if (this.invertTimer > this.config.INVERT_FADE_DURATION) {\r\n                this.invertTimer = 0;\r\n                this.invertTrigger = false;\r\n                this.invert();\r\n            } else if (this.invertTimer) {\r\n                this.invertTimer += deltaTime;\r\n            } else {\r\n                var actualDistance =\r\n                    this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));\r\n\r\n                if (actualDistance > 0) {\r\n                    this.invertTrigger = !(actualDistance %\r\n                        this.config.INVERT_DISTANCE);\r\n\r\n                    if (this.invertTrigger && this.invertTimer === 0) {\r\n                        this.invertTimer += deltaTime;\r\n                        this.invert();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.playing || (!this.activated &&\r\n            this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {\r\n            this.tRex.update(deltaTime);\r\n            this.scheduleNextUpdate();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Event handler.\r\n     */\r\n    handleEvent: function (e) {\r\n        return (function (evtType, events) {\r\n            switch (evtType) {\r\n                case events.KEYDOWN:\r\n                case events.TOUCHSTART:\r\n                case events.MOUSEDOWN:\r\n                    this.onKeyDown(e);\r\n                    break;\r\n                case events.KEYUP:\r\n                case events.TOUCHEND:\r\n                case events.MOUSEUP:\r\n                    this.onKeyUp(e);\r\n                    break;\r\n            }\r\n        }.bind(this))(e.type, Runner.events);\r\n    },\r\n\r\n    /**\r\n     * Bind relevant key / mouse / touch listeners.\r\n     */\r\n    startListening: function () {\r\n        // Keys.\r\n        document.addEventListener(Runner.events.KEYDOWN, this);\r\n        document.addEventListener(Runner.events.KEYUP, this);\r\n\r\n        if (IS_MOBILE) {\r\n            // Mobile only touch devices.\r\n            this.touchController.addEventListener(Runner.events.TOUCHSTART, this);\r\n            this.touchController.addEventListener(Runner.events.TOUCHEND, this);\r\n            this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);\r\n        } else {\r\n            // Mouse.\r\n            document.addEventListener(Runner.events.MOUSEDOWN, this);\r\n            document.addEventListener(Runner.events.MOUSEUP, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stopListening: function () {\r\n        document.removeEventListener(Runner.events.KEYDOWN, this);\r\n        document.removeEventListener(Runner.events.KEYUP, this);\r\n\r\n        if (IS_MOBILE) {\r\n            this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);\r\n            this.touchController.removeEventListener(Runner.events.TOUCHEND, this);\r\n            this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);\r\n        } else {\r\n            document.removeEventListener(Runner.events.MOUSEDOWN, this);\r\n            document.removeEventListener(Runner.events.MOUSEUP, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Process keydown.\r\n     * @param {Event} e\r\n     */\r\n    onKeyDown: function (e) {\r\n        // Prevent native page scrolling whilst tapping on mobile.\r\n        if (IS_MOBILE && this.playing) {\r\n            e.preventDefault();\r\n        }\r\n\r\n        if (!this.crashed && !this.paused) {\r\n            if (Runner.keycodes.JUMP[e.keyCode] ||\r\n                e.type == Runner.events.TOUCHSTART) {\r\n                e.preventDefault();\r\n                // Starting the game for the first time.\r\n                if (!this.playing) {\r\n                    this.loadSounds();\r\n                    this.playing = true;\r\n                    this.update();\r\n                    if (window.errorPageController) {\r\n                        errorPageController.trackEasterEgg();\r\n                    }\r\n                }\r\n                // Start jump.\r\n                if (!this.tRex.jumping && !this.tRex.ducking) {\r\n                    this.playSound(this.soundFx.BUTTON_PRESS);\r\n                    this.tRex.startJump(this.currentSpeed);\r\n                }\r\n            } else if (this.playing && Runner.keycodes.DUCK[e.keyCode]) {\r\n                e.preventDefault();\r\n                if (this.tRex.jumping) {\r\n                    // Speed drop, activated only when jump key is not pressed.\r\n                    this.tRex.setSpeedDrop();\r\n                } else if (!this.tRex.jumping && !this.tRex.ducking) {\r\n                    // Duck.\r\n                    this.tRex.setDuck(true);\r\n                }\r\n            }\r\n        } else if (this.crashed && e.type == Runner.events.TOUCHSTART &&\r\n            e.currentTarget == this.containerEl) {\r\n            this.restart();\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * Process key up.\r\n     * @param {Event} e\r\n     */\r\n    onKeyUp: function (e) {\r\n        var keyCode = String(e.keyCode);\r\n        var isjumpKey = Runner.keycodes.JUMP[keyCode] ||\r\n            e.type == Runner.events.TOUCHEND ||\r\n            e.type == Runner.events.MOUSEDOWN;\r\n\r\n        if (this.isRunning() && isjumpKey) {\r\n            this.tRex.endJump();\r\n        } else if (Runner.keycodes.DUCK[keyCode]) {\r\n            this.tRex.speedDrop = false;\r\n            this.tRex.setDuck(false);\r\n        } else if (this.crashed) {\r\n            // Check that enough time has elapsed before allowing jump key to restart.\r\n            var deltaTime = getTimeStamp() - this.time;\r\n\r\n            if (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||\r\n                (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&\r\n                    Runner.keycodes.JUMP[keyCode])) {\r\n                this.restart();\r\n            }\r\n        } else if (this.paused && isjumpKey) {\r\n            // Reset the jump state\r\n            this.tRex.reset();\r\n            this.play();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns whether the event was a left click on canvas.\r\n     * On Windows right click is registered as a click.\r\n     * @param {Event} e\r\n     * @return {boolean}\r\n     */\r\n    isLeftClickOnCanvas: function (e) {\r\n        return e.button != null && e.button < 2 &&\r\n            e.type == Runner.events.MOUSEUP && e.target == this.canvas;\r\n    },\r\n\r\n    /**\r\n     * RequestAnimationFrame wrapper.\r\n     */\r\n    scheduleNextUpdate: function () {\r\n        if (!this.updatePending) {\r\n            this.updatePending = true;\r\n            this.raqId = requestAnimationFrame(this.update.bind(this));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Whether the game is running.\r\n     * @return {boolean}\r\n     */\r\n    isRunning: function () {\r\n        return !!this.raqId;\r\n    },\r\n\r\n    /**\r\n     * Game over state.\r\n     */\r\n    gameOver: function () {\r\n        this.playSound(this.soundFx.HIT);\r\n        vibrate(200);\r\n\r\n        this.stop();\r\n        this.crashed = true;\r\n        this.distanceMeter.achievement = false;\r\n\r\n        this.tRex.update(100, Trex.status.CRASHED);\r\n\r\n        // Game over panel.\r\n        if (!this.gameOverPanel) {\r\n            this.gameOverPanel = new GameOverPanel(this.canvas,\r\n                this.spriteDef.TEXT_SPRITE, this.spriteDef.RESTART,\r\n                this.dimensions);\r\n        } else {\r\n            this.gameOverPanel.draw();\r\n        }\r\n\r\n        // Update the high score.\r\n        if (this.distanceRan > this.highestScore) {\r\n            this.highestScore = Math.ceil(this.distanceRan);\r\n            this.distanceMeter.setHighScore(this.highestScore);\r\n        }\r\n\r\n        // Reset the time clock.\r\n        this.time = getTimeStamp();\r\n    },\r\n\r\n    stop: function () {\r\n        this.playing = false;\r\n        this.paused = true;\r\n        cancelAnimationFrame(this.raqId);\r\n        this.raqId = 0;\r\n    },\r\n\r\n    play: function () {\r\n        if (!this.crashed) {\r\n            this.playing = true;\r\n            this.paused = false;\r\n            this.tRex.update(0, Trex.status.RUNNING);\r\n            this.time = getTimeStamp();\r\n            this.update();\r\n        }\r\n    },\r\n\r\n    restart: function () {\r\n        if (!this.raqId) {\r\n            this.playCount++;\r\n            this.runningTime = 0;\r\n            this.playing = true;\r\n            this.paused = false;\r\n            this.crashed = false;\r\n            this.distanceRan = 0;\r\n            this.setSpeed(this.config.SPEED);\r\n            this.time = getTimeStamp();\r\n            this.containerEl.classList.remove(Runner.classes.CRASHED);\r\n            this.clearCanvas();\r\n            this.distanceMeter.reset(this.highestScore);\r\n            this.horizon.reset();\r\n            this.tRex.reset();\r\n            this.playSound(this.soundFx.BUTTON_PRESS);\r\n            this.invert(true);\r\n            this.update();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Whether the game should go into arcade mode.\r\n     * @return {boolean}\r\n     */\r\n    isArcadeMode: function () {\r\n        return document.title == ARCADE_MODE_URL;\r\n    },\r\n\r\n    /**\r\n     * Hides offline messaging for a fullscreen game only experience.\r\n     */\r\n    setArcadeMode: function () {\r\n        document.body.classList.add(Runner.classes.ARCADE_MODE);\r\n        this.setArcadeModeContainerScale();\r\n    },\r\n\r\n    /**\r\n     * Sets the scaling for arcade mode.\r\n     */\r\n    setArcadeModeContainerScale: function () {\r\n        var windowHeight = window.innerHeight;\r\n        var scaleHeight = windowHeight / this.dimensions.HEIGHT;\r\n        var scaleWidth = window.innerWidth / this.dimensions.WIDTH;\r\n        var scale = Math.max(1, Math.min(scaleHeight, scaleWidth));\r\n        var scaledCanvasHeight = this.dimensions.HEIGHT * scale;\r\n        // Positions the game container at 10% of the available vertical window\r\n        // height minus the game container height.\r\n        var translateY = Math.ceil(Math.max(0, (windowHeight - scaledCanvasHeight -\r\n            Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION) *\r\n            Runner.config.ARCADE_MODE_TOP_POSITION_PERCENT)) *\r\n            window.devicePixelRatio;\r\n        this.containerEl.style.transform = 'scale(' + scale + ') translateY(' +\r\n            translateY + 'px)';\r\n    },\r\n\r\n    /**\r\n     * Pause the game if the tab is not in focus.\r\n     */\r\n    onVisibilityChange: function (e) {\r\n        if (document.hidden || document.webkitHidden || e.type == 'blur' ||\r\n            document.visibilityState != 'visible') {\r\n            this.stop();\r\n        } else if (!this.crashed) {\r\n            this.tRex.reset();\r\n            this.play();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Play a sound.\r\n     * @param {SoundBuffer} soundBuffer\r\n     */\r\n    playSound: function (soundBuffer) {\r\n        if (soundBuffer) {\r\n            var sourceNode = this.audioContext.createBufferSource();\r\n            sourceNode.buffer = soundBuffer;\r\n            sourceNode.connect(this.audioContext.destination);\r\n            sourceNode.start(0);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Inverts the current page / canvas colors.\r\n     * @param {boolean} Whether to reset colors.\r\n     */\r\n    invert: function (reset) {\r\n        if (reset) {\r\n            document.body.classList.toggle(Runner.classes.INVERTED, false);\r\n            this.invertTimer = 0;\r\n            this.inverted = false;\r\n        } else {\r\n            this.inverted = document.body.classList.toggle(Runner.classes.INVERTED,\r\n                this.invertTrigger);\r\n        }\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Updates the canvas size taking into\r\n * account the backing store pixel ratio and\r\n * the device pixel ratio.\r\n *\r\n * See article by Paul Lewis:\r\n * http://www.html5rocks.com/en/tutorials/canvas/hidpi/\r\n *\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {number} opt_width\r\n * @param {number} opt_height\r\n * @return {boolean} Whether the canvas was scaled.\r\n */\r\nRunner.updateCanvasScaling = function (canvas, opt_width, opt_height) {\r\n    var context = canvas.getContext('2d');\r\n\r\n    // Query the various pixel ratios\r\n    var devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;\r\n    var backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;\r\n    var ratio = devicePixelRatio / backingStoreRatio;\r\n\r\n    // Upscale the canvas if the two ratios don't match\r\n    if (devicePixelRatio !== backingStoreRatio) {\r\n        var oldWidth = opt_width || canvas.width;\r\n        var oldHeight = opt_height || canvas.height;\r\n\r\n        canvas.width = oldWidth * ratio;\r\n        canvas.height = oldHeight * ratio;\r\n\r\n        canvas.style.width = oldWidth + 'px';\r\n        canvas.style.height = oldHeight + 'px';\r\n\r\n        // Scale the context to counter the fact that we've manually scaled\r\n        // our canvas element.\r\n        context.scale(ratio, ratio);\r\n        return true;\r\n    } else if (devicePixelRatio == 1) {\r\n        // Reset the canvas width / height. Fixes scaling bug when the page is\r\n        // zoomed and the devicePixelRatio changes accordingly.\r\n        canvas.style.width = canvas.width + 'px';\r\n        canvas.style.height = canvas.height + 'px';\r\n    }\r\n    return false;\r\n};\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\n\r\n\r\n/**\r\n * Vibrate on mobile devices.\r\n * @param {number} duration Duration of the vibration in milliseconds.\r\n */\r\nfunction vibrate(duration) {\r\n    if (IS_MOBILE && window.navigator.vibrate) {\r\n        window.navigator.vibrate(duration);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Create canvas element.\r\n * @param {HTMLElement} container Element to append canvas to.\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {string} opt_classname\r\n * @return {HTMLCanvasElement}\r\n */\r\nfunction createCanvas(container, width, height, opt_classname) {\r\n    var canvas = document.createElement('canvas');\r\n    canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +\r\n        opt_classname : Runner.classes.CANVAS;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    container.appendChild(canvas);\r\n\r\n    return canvas;\r\n}\r\n\r\n\r\n/**\r\n * Decodes the base 64 audio to ArrayBuffer used by Web Audio.\r\n * @param {string} base64String\r\n */\r\nfunction decodeBase64ToArrayBuffer(base64String) {\r\n    var len = (base64String.length / 4) * 3;\r\n    var str = atob(base64String);\r\n    var arrayBuffer = new ArrayBuffer(len);\r\n    var bytes = new Uint8Array(arrayBuffer);\r\n\r\n    for (var i = 0; i < len; i++) {\r\n        bytes[i] = str.charCodeAt(i);\r\n    }\r\n    return bytes.buffer;\r\n}\r\n\r\n\r\n/**\r\n * Return the current timestamp.\r\n * @return {number}\r\n */\r\nfunction getTimeStamp() {\r\n    return IS_IOS ? new Date().getTime() : performance.now();\r\n}\r\n\r\n\r\n//******************************************************************************\r\n\r\n\r\n/**\r\n * Game over panel.\r\n * @param {!HTMLCanvasElement} canvas\r\n * @param {Object} textImgPos\r\n * @param {Object} restartImgPos\r\n * @param {!Object} dimensions Canvas dimensions.\r\n * @constructor\r\n */\r\nfunction GameOverPanel(canvas, textImgPos, restartImgPos, dimensions) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.canvasDimensions = dimensions;\r\n    this.textImgPos = textImgPos;\r\n    this.restartImgPos = restartImgPos;\r\n    this.draw();\r\n};\r\n\r\n\r\n/**\r\n * Dimensions used in the panel.\r\n * @enum {number}\r\n */\r\nGameOverPanel.dimensions = {\r\n    TEXT_X: 0,\r\n    TEXT_Y: 13,\r\n    TEXT_WIDTH: 191,\r\n    TEXT_HEIGHT: 11,\r\n    RESTART_WIDTH: 36,\r\n    RESTART_HEIGHT: 32\r\n};\r\n\r\n\r\nGameOverPanel.prototype = {\r\n    /**\r\n     * Update the panel dimensions.\r\n     * @param {number} width New canvas width.\r\n     * @param {number} opt_height Optional new canvas height.\r\n     */\r\n    updateDimensions: function (width, opt_height) {\r\n        this.canvasDimensions.WIDTH = width;\r\n        if (opt_height) {\r\n            this.canvasDimensions.HEIGHT = opt_height;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Draw the panel.\r\n     */\r\n    draw: function () {\r\n        var dimensions = GameOverPanel.dimensions;\r\n\r\n        var centerX = this.canvasDimensions.WIDTH / 2;\r\n\r\n        // Game over text.\r\n        var textSourceX = dimensions.TEXT_X;\r\n        var textSourceY = dimensions.TEXT_Y;\r\n        var textSourceWidth = dimensions.TEXT_WIDTH;\r\n        var textSourceHeight = dimensions.TEXT_HEIGHT;\r\n\r\n        var textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));\r\n        var textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);\r\n        var textTargetWidth = dimensions.TEXT_WIDTH;\r\n        var textTargetHeight = dimensions.TEXT_HEIGHT;\r\n\r\n        var restartSourceWidth = dimensions.RESTART_WIDTH;\r\n        var restartSourceHeight = dimensions.RESTART_HEIGHT;\r\n        var restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);\r\n        var restartTargetY = this.canvasDimensions.HEIGHT / 2;\r\n\r\n        if (IS_HIDPI) {\r\n            textSourceY *= 2;\r\n            textSourceX *= 2;\r\n            textSourceWidth *= 2;\r\n            textSourceHeight *= 2;\r\n            restartSourceWidth *= 2;\r\n            restartSourceHeight *= 2;\r\n        }\r\n\r\n        textSourceX += this.textImgPos.x;\r\n        textSourceY += this.textImgPos.y;\r\n\r\n        // Game over text from sprite.\r\n        this.canvasCtx.drawImage(Runner.imageSprite,\r\n            textSourceX, textSourceY, textSourceWidth, textSourceHeight,\r\n            textTargetX, textTargetY, textTargetWidth, textTargetHeight);\r\n\r\n        // Restart button.\r\n        this.canvasCtx.drawImage(Runner.imageSprite,\r\n            this.restartImgPos.x, this.restartImgPos.y,\r\n            restartSourceWidth, restartSourceHeight,\r\n            restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,\r\n            dimensions.RESTART_HEIGHT);\r\n    }\r\n};\r\n\r\n\r\n//******************************************************************************\r\n\r\n/**\r\n * Check for a collision.\r\n * @param {!Obstacle} obstacle\r\n * @param {!Trex} tRex T-rex object.\r\n * @param {HTMLCanvasContext} opt_canvasCtx Optional canvas context for drawing\r\n *    collision boxes.\r\n * @return {Array<CollisionBox>}\r\n */\r\nfunction checkForCollision(obstacle, tRex, opt_canvasCtx) {\r\n    var obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;\r\n\r\n    // Adjustments are made to the bounding box as there is a 1 pixel white\r\n    // border around the t-rex and obstacles.\r\n    var tRexBox = new CollisionBox(\r\n        tRex.xPos + 1,\r\n        tRex.yPos + 1,\r\n        tRex.config.WIDTH - 2,\r\n        tRex.config.HEIGHT - 2);\r\n\r\n    var obstacleBox = new CollisionBox(\r\n        obstacle.xPos + 1,\r\n        obstacle.yPos + 1,\r\n        obstacle.typeConfig.width * obstacle.size - 2,\r\n        obstacle.typeConfig.height - 2);\r\n\r\n    // Debug outer box\r\n    if (opt_canvasCtx) {\r\n        drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);\r\n    }\r\n\r\n    // Simple outer bounds check.\r\n    if (boxCompare(tRexBox, obstacleBox)) {\r\n        var collisionBoxes = obstacle.collisionBoxes;\r\n        var tRexCollisionBoxes = tRex.ducking ?\r\n            Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;\r\n\r\n        // Detailed axis aligned box check.\r\n        for (var t = 0; t < tRexCollisionBoxes.length; t++) {\r\n            for (var i = 0; i < collisionBoxes.length; i++) {\r\n                // Adjust the box to actual positions.\r\n                var adjTrexBox =\r\n                    createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);\r\n                var adjObstacleBox =\r\n                    createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);\r\n                var crashed = boxCompare(adjTrexBox, adjObstacleBox);\r\n\r\n                // Draw boxes for debug.\r\n                if (opt_canvasCtx) {\r\n                    drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);\r\n                }\r\n\r\n                if (crashed) {\r\n                    return [adjTrexBox, adjObstacleBox];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n\r\n/**\r\n * Adjust the collision box.\r\n * @param {!CollisionBox} box The original box.\r\n * @param {!CollisionBox} adjustment Adjustment box.\r\n * @return {CollisionBox} The adjusted collision box object.\r\n */\r\nfunction createAdjustedCollisionBox(box, adjustment) {\r\n    return new CollisionBox(\r\n        box.x + adjustment.x,\r\n        box.y + adjustment.y,\r\n        box.width,\r\n        box.height);\r\n};\r\n\r\n\r\n/**\r\n * Draw the collision boxes for debug.\r\n */\r\nfunction drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {\r\n    canvasCtx.save();\r\n    canvasCtx.strokeStyle = '#f00';\r\n    canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);\r\n\r\n    canvasCtx.strokeStyle = '#0f0';\r\n    canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,\r\n        obstacleBox.width, obstacleBox.height);\r\n    canvasCtx.restore();\r\n};\r\n\r\n\r\n/**\r\n * Compare two collision boxes for a collision.\r\n * @param {CollisionBox} tRexBox\r\n * @param {CollisionBox} obstacleBox\r\n * @return {boolean} Whether the boxes intersected.\r\n */\r\nfunction boxCompare(tRexBox, obstacleBox) {\r\n    var crashed = false;\r\n    var tRexBoxX = tRexBox.x;\r\n    var tRexBoxY = tRexBox.y;\r\n\r\n    var obstacleBoxX = obstacleBox.x;\r\n    var obstacleBoxY = obstacleBox.y;\r\n\r\n    // Axis-Aligned Bounding Box method.\r\n    if (tRexBox.x < obstacleBoxX + obstacleBox.width &&\r\n        tRexBox.x + tRexBox.width > obstacleBoxX &&\r\n        tRexBox.y < obstacleBox.y + obstacleBox.height &&\r\n        tRexBox.height + tRexBox.y > obstacleBox.y) {\r\n        crashed = true;\r\n    }\r\n\r\n    return crashed;\r\n};\r\n\r\n\r\n//******************************************************************************\r\n/**\r\n * T-rex game character.\r\n * @param {HTMLCanvas} canvas\r\n * @param {Object} spritePos Positioning within image sprite.\r\n * @constructor\r\n */\r\nfunction Trex(canvas, spritePos) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.spritePos = spritePos;\r\n    this.xPos = 0;\r\n    this.yPos = 0;\r\n    // Position when on the ground.\r\n    this.groundYPos = 0;\r\n    this.currentFrame = 0;\r\n    this.currentAnimFrames = [];\r\n    this.blinkDelay = 0;\r\n    this.blinkCount = 0;\r\n    this.animStartTime = 0;\r\n    this.timer = 0;\r\n    this.msPerFrame = 1000 / FPS;\r\n    this.config = Trex.config;\r\n    // Current status.\r\n    this.status = Trex.status.WAITING;\r\n\r\n    this.jumping = false;\r\n    this.ducking = false;\r\n    this.jumpVelocity = 0;\r\n    this.reachedMinHeight = false;\r\n    this.speedDrop = false;\r\n    this.jumpCount = 0;\r\n    this.jumpspotX = 0;\r\n\r\n    this.init();\r\n};\r\n\r\n\r\n/**\r\n * T-rex player config.\r\n * @enum {number}\r\n */\r\nTrex.config = {\r\n    DROP_VELOCITY: -5,\r\n    GRAVITY: 0.6,\r\n    HEIGHT: 47,\r\n    HEIGHT_DUCK: 25,\r\n    INIITAL_JUMP_VELOCITY: -10,\r\n    INTRO_DURATION: 1500,\r\n    MAX_JUMP_HEIGHT: 30,\r\n    MIN_JUMP_HEIGHT: 30,\r\n    SPEED_DROP_COEFFICIENT: 3,\r\n    SPRITE_WIDTH: 262,\r\n    START_X_POS: 50,\r\n    WIDTH: 44,\r\n    WIDTH_DUCK: 59\r\n};\r\n\r\n\r\n/**\r\n * Used in collision detection.\r\n * @type {Array<CollisionBox>}\r\n */\r\nTrex.collisionBoxes = {\r\n    DUCKING: [\r\n        new CollisionBox(1, 18, 55, 25)\r\n    ],\r\n    RUNNING: [\r\n        new CollisionBox(22, 0, 17, 16),\r\n        new CollisionBox(1, 18, 30, 9),\r\n        new CollisionBox(10, 35, 14, 8),\r\n        new CollisionBox(1, 24, 29, 5),\r\n        new CollisionBox(5, 30, 21, 4),\r\n        new CollisionBox(9, 34, 15, 4)\r\n    ]\r\n};\r\n\r\n\r\n/**\r\n * Animation states.\r\n * @enum {string}\r\n */\r\nTrex.status = {\r\n    CRASHED: 'CRASHED',\r\n    DUCKING: 'DUCKING',\r\n    JUMPING: 'JUMPING',\r\n    RUNNING: 'RUNNING',\r\n    WAITING: 'WAITING'\r\n};\r\n\r\n/**\r\n * Blinking coefficient.\r\n * @const\r\n */\r\nTrex.BLINK_TIMING = 7000;\r\n\r\n\r\n/**\r\n * Animation config for different states.\r\n * @enum {Object}\r\n */\r\nTrex.animFrames = {\r\n    WAITING: {\r\n        frames: [44, 0],\r\n        msPerFrame: 1000 / 3\r\n    },\r\n    RUNNING: {\r\n        frames: [88, 132],\r\n        msPerFrame: 1000 / 12\r\n    },\r\n    CRASHED: {\r\n        frames: [220],\r\n        msPerFrame: 1000 / 60\r\n    },\r\n    JUMPING: {\r\n        frames: [0],\r\n        msPerFrame: 1000 / 60\r\n    },\r\n    DUCKING: {\r\n        frames: [262, 321],\r\n        msPerFrame: 1000 / 8\r\n    }\r\n};\r\n\r\n\r\nTrex.prototype = {\r\n    /**\r\n     * T-rex player initaliser.\r\n     * Sets the t-rex to blink at random intervals.\r\n     */\r\n    init: function () {\r\n        this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -\r\n            Runner.config.BOTTOM_PAD;\r\n        this.yPos = this.groundYPos;\r\n        this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;\r\n\r\n        this.draw(0, 0);\r\n        this.update(0, Trex.status.WAITING);\r\n    },\r\n\r\n    /**\r\n     * Setter for the jump velocity.\r\n     * The approriate drop velocity is also set.\r\n     */\r\n    setJumpVelocity: function (setting) {\r\n        this.config.INIITAL_JUMP_VELOCITY = -setting;\r\n        this.config.DROP_VELOCITY = -setting / 2;\r\n    },\r\n\r\n    /**\r\n     * Set the animation status.\r\n     * @param {!number} deltaTime\r\n     * @param {Trex.status} status Optional status to switch to.\r\n     */\r\n    update: function (deltaTime, opt_status) {\r\n        this.timer += deltaTime;\r\n\r\n        // Update the status.\r\n        if (opt_status) {\r\n            this.status = opt_status;\r\n            this.currentFrame = 0;\r\n            this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;\r\n            this.currentAnimFrames = Trex.animFrames[opt_status].frames;\r\n\r\n            if (opt_status == Trex.status.WAITING) {\r\n                this.animStartTime = getTimeStamp();\r\n                this.setBlinkDelay();\r\n            }\r\n        }\r\n\r\n        // Game intro animation, T-rex moves in from the left.\r\n        if (this.playingIntro && this.xPos < this.config.START_X_POS) {\r\n            this.xPos += Math.round((this.config.START_X_POS /\r\n                this.config.INTRO_DURATION) * deltaTime);\r\n        }\r\n\r\n        if (this.status == Trex.status.WAITING) {\r\n            this.blink(getTimeStamp());\r\n        } else {\r\n            this.draw(this.currentAnimFrames[this.currentFrame], 0);\r\n        }\r\n\r\n        // Update the frame position.\r\n        if (this.timer >= this.msPerFrame) {\r\n            this.currentFrame = this.currentFrame ==\r\n                this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;\r\n            this.timer = 0;\r\n        }\r\n\r\n        // Speed drop becomes duck if the down key is still being pressed.\r\n        if (this.speedDrop && this.yPos == this.groundYPos) {\r\n            this.speedDrop = false;\r\n            this.setDuck(true);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Draw the t-rex to a particular position.\r\n     * @param {number} x\r\n     * @param {number} y\r\n     */\r\n    draw: function (x, y) {\r\n        var sourceX = x;\r\n        var sourceY = y;\r\n        var sourceWidth = this.ducking && this.status != Trex.status.CRASHED ?\r\n            this.config.WIDTH_DUCK : this.config.WIDTH;\r\n        var sourceHeight = this.config.HEIGHT;\r\n\r\n        if (IS_HIDPI) {\r\n            sourceX *= 2;\r\n            sourceY *= 2;\r\n            sourceWidth *= 2;\r\n            sourceHeight *= 2;\r\n        }\r\n\r\n        // Adjustments for sprite sheet position.\r\n        sourceX += this.spritePos.x;\r\n        sourceY += this.spritePos.y;\r\n\r\n        // Ducking.\r\n        if (this.ducking && this.status != Trex.status.CRASHED) {\r\n            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,\r\n                sourceWidth, sourceHeight,\r\n                this.xPos, this.yPos,\r\n                this.config.WIDTH_DUCK, this.config.HEIGHT);\r\n        } else {\r\n            // Crashed whilst ducking. Trex is standing up so needs adjustment.\r\n            if (this.ducking && this.status == Trex.status.CRASHED) {\r\n                this.xPos++;\r\n            }\r\n            // Standing / running\r\n            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,\r\n                sourceWidth, sourceHeight,\r\n                this.xPos, this.yPos,\r\n                this.config.WIDTH, this.config.HEIGHT);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a random time for the blink to happen.\r\n     */\r\n    setBlinkDelay: function () {\r\n        this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);\r\n    },\r\n\r\n    /**\r\n     * Make t-rex blink at random intervals.\r\n     * @param {number} time Current time in milliseconds.\r\n     */\r\n    blink: function (time) {\r\n        var deltaTime = time - this.animStartTime;\r\n\r\n        if (deltaTime >= this.blinkDelay) {\r\n            this.draw(this.currentAnimFrames[this.currentFrame], 0);\r\n\r\n            if (this.currentFrame == 1) {\r\n                // Set new random delay to blink.\r\n                this.setBlinkDelay();\r\n                this.animStartTime = time;\r\n                this.blinkCount++;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Initialise a jump.\r\n     * @param {number} speed\r\n     */\r\n    startJump: function (speed) {\r\n        if (!this.jumping) {\r\n            this.update(0, Trex.status.JUMPING);\r\n            // Tweak the jump velocity based on the speed.\r\n            this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - (speed / 10);\r\n            this.jumping = true;\r\n            this.reachedMinHeight = false;\r\n            this.speedDrop = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Jump is complete, falling down.\r\n     */\r\n    endJump: function () {\r\n        if (this.reachedMinHeight &&\r\n            this.jumpVelocity < this.config.DROP_VELOCITY) {\r\n            this.jumpVelocity = this.config.DROP_VELOCITY;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Update frame for a jump.\r\n     * @param {number} deltaTime\r\n     * @param {number} speed\r\n     */\r\n    updateJump: function (deltaTime, speed) {\r\n        var msPerFrame = Trex.animFrames[this.status].msPerFrame;\r\n        var framesElapsed = deltaTime / msPerFrame;\r\n\r\n        // Speed drop makes Trex fall faster.\r\n        if (this.speedDrop) {\r\n            this.yPos += Math.round(this.jumpVelocity *\r\n                this.config.SPEED_DROP_COEFFICIENT * framesElapsed);\r\n        } else {\r\n            this.yPos += Math.round(this.jumpVelocity * framesElapsed);\r\n        }\r\n\r\n        this.jumpVelocity += this.config.GRAVITY * framesElapsed;\r\n\r\n        // Minimum height has been reached.\r\n        if (this.yPos < this.minJumpHeight || this.speedDrop) {\r\n            this.reachedMinHeight = true;\r\n        }\r\n\r\n        // Reached max height\r\n        if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) {\r\n            this.endJump();\r\n        }\r\n\r\n        // Back down at ground level. Jump completed.\r\n        if (this.yPos > this.groundYPos) {\r\n            this.reset();\r\n            this.jumpCount++;\r\n        }\r\n\r\n        this.update(deltaTime);\r\n    },\r\n\r\n    /**\r\n     * Set the speed drop. Immediately cancels the current jump.\r\n     */\r\n    setSpeedDrop: function () {\r\n        this.speedDrop = true;\r\n        this.jumpVelocity = 1;\r\n    },\r\n\r\n    /**\r\n     * @param {boolean} isDucking.\r\n     */\r\n    setDuck: function (isDucking) {\r\n        if (isDucking && this.status != Trex.status.DUCKING) {\r\n            this.update(0, Trex.status.DUCKING);\r\n            this.ducking = true;\r\n        } else if (this.status == Trex.status.DUCKING) {\r\n            this.update(0, Trex.status.RUNNING);\r\n            this.ducking = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Reset the t-rex to running at start of game.\r\n     */\r\n    reset: function () {\r\n        this.yPos = this.groundYPos;\r\n        this.jumpVelocity = 0;\r\n        this.jumping = false;\r\n        this.ducking = false;\r\n        this.update(0, Trex.status.RUNNING);\r\n        this.midair = false;\r\n        this.speedDrop = false;\r\n        this.jumpCount = 0;\r\n    }\r\n};\r\n\r\n\r\n//******************************************************************************\r\n\r\n/**\r\n * Handles displaying the distance meter.\r\n * @param {!HTMLCanvasElement} canvas\r\n * @param {Object} spritePos Image position in sprite.\r\n * @param {number} canvasWidth\r\n * @constructor\r\n */\r\nfunction DistanceMeter(canvas, spritePos, canvasWidth) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.image = Runner.imageSprite;\r\n    this.spritePos = spritePos;\r\n    this.x = 0;\r\n    this.y = 5;\r\n\r\n    this.currentDistance = 0;\r\n    this.maxScore = 0;\r\n    this.highScore = 0;\r\n    this.container = null;\r\n\r\n    this.digits = [];\r\n    this.achievement = false;\r\n    this.defaultString = '';\r\n    this.flashTimer = 0;\r\n    this.flashIterations = 0;\r\n    this.invertTrigger = false;\r\n\r\n    this.config = DistanceMeter.config;\r\n    this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;\r\n    this.init(canvasWidth);\r\n};\r\n\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nDistanceMeter.dimensions = {\r\n    WIDTH: 10,\r\n    HEIGHT: 13,\r\n    DEST_WIDTH: 11\r\n};\r\n\r\n\r\n/**\r\n * Y positioning of the digits in the sprite sheet.\r\n * X position is always 0.\r\n * @type {Array<number>}\r\n */\r\nDistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];\r\n\r\n\r\n/**\r\n * Distance meter config.\r\n * @enum {number}\r\n */\r\nDistanceMeter.config = {\r\n    // Number of digits.\r\n    MAX_DISTANCE_UNITS: 5,\r\n\r\n    // Distance that causes achievement animation.\r\n    ACHIEVEMENT_DISTANCE: 100,\r\n\r\n    // Used for conversion from pixel distance to a scaled unit.\r\n    COEFFICIENT: 0.025,\r\n\r\n    // Flash duration in milliseconds.\r\n    FLASH_DURATION: 1000 / 4,\r\n\r\n    // Flash iterations for achievement animation.\r\n    FLASH_ITERATIONS: 3\r\n};\r\n\r\n\r\nDistanceMeter.prototype = {\r\n    /**\r\n     * Initialise the distance meter to '00000'.\r\n     * @param {number} width Canvas width in px.\r\n     */\r\n    init: function (width) {\r\n        var maxDistanceStr = '';\r\n\r\n        this.calcXPos(width);\r\n        this.maxScore = this.maxScoreUnits;\r\n        for (var i = 0; i < this.maxScoreUnits; i++) {\r\n            this.draw(i, 0);\r\n            this.defaultString += '0';\r\n            maxDistanceStr += '9';\r\n        }\r\n\r\n        this.maxScore = parseInt(maxDistanceStr);\r\n    },\r\n\r\n    /**\r\n     * Calculate the xPos in the canvas.\r\n     * @param {number} canvasWidth\r\n     */\r\n    calcXPos: function (canvasWidth) {\r\n        this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *\r\n            (this.maxScoreUnits + 1));\r\n    },\r\n\r\n    /**\r\n     * Draw a digit to canvas.\r\n     * @param {number} digitPos Position of the digit.\r\n     * @param {number} value Digit value 0-9.\r\n     * @param {boolean} opt_highScore Whether drawing the high score.\r\n     */\r\n    draw: function (digitPos, value, opt_highScore) {\r\n        var sourceWidth = DistanceMeter.dimensions.WIDTH;\r\n        var sourceHeight = DistanceMeter.dimensions.HEIGHT;\r\n        var sourceX = DistanceMeter.dimensions.WIDTH * value;\r\n        var sourceY = 0;\r\n\r\n        var targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;\r\n        var targetY = this.y;\r\n        var targetWidth = DistanceMeter.dimensions.WIDTH;\r\n        var targetHeight = DistanceMeter.dimensions.HEIGHT;\r\n\r\n        // For high DPI we 2x source values.\r\n        if (IS_HIDPI) {\r\n            sourceWidth *= 2;\r\n            sourceHeight *= 2;\r\n            sourceX *= 2;\r\n        }\r\n\r\n        sourceX += this.spritePos.x;\r\n        sourceY += this.spritePos.y;\r\n\r\n        this.canvasCtx.save();\r\n\r\n        if (opt_highScore) {\r\n            // Left of the current score.\r\n            var highScoreX = this.x - (this.maxScoreUnits * 2) *\r\n                DistanceMeter.dimensions.WIDTH;\r\n            this.canvasCtx.translate(highScoreX, this.y);\r\n        } else {\r\n            this.canvasCtx.translate(this.x, this.y);\r\n        }\r\n\r\n        this.canvasCtx.drawImage(this.image, sourceX, sourceY,\r\n            sourceWidth, sourceHeight,\r\n            targetX, targetY,\r\n            targetWidth, targetHeight\r\n        );\r\n\r\n        this.canvasCtx.restore();\r\n    },\r\n\r\n    /**\r\n     * Covert pixel distance to a 'real' distance.\r\n     * @param {number} distance Pixel distance ran.\r\n     * @return {number} The 'real' distance ran.\r\n     */\r\n    getActualDistance: function (distance) {\r\n        return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;\r\n    },\r\n\r\n    /**\r\n     * Update the distance meter.\r\n     * @param {number} distance\r\n     * @param {number} deltaTime\r\n     * @return {boolean} Whether the acheivement sound fx should be played.\r\n     */\r\n    update: function (deltaTime, distance) {\r\n        var paint = true;\r\n        var playSound = false;\r\n\r\n        if (!this.achievement) {\r\n            distance = this.getActualDistance(distance);\r\n            // Score has gone beyond the initial digit count.\r\n            if (distance > this.maxScore && this.maxScoreUnits ==\r\n                this.config.MAX_DISTANCE_UNITS) {\r\n                this.maxScoreUnits++;\r\n                this.maxScore = parseInt(this.maxScore + '9');\r\n            } else {\r\n                this.distance = 0;\r\n            }\r\n\r\n            if (distance > 0) {\r\n                // Acheivement unlocked\r\n                if (distance % this.config.ACHIEVEMENT_DISTANCE == 0) {\r\n                    // Flash score and play sound.\r\n                    this.achievement = true;\r\n                    this.flashTimer = 0;\r\n                    playSound = true;\r\n                }\r\n\r\n                // Create a string representation of the distance with leading 0.\r\n                var distanceStr = (this.defaultString +\r\n                    distance).substr(-this.maxScoreUnits);\r\n                this.digits = distanceStr.split('');\r\n            } else {\r\n                this.digits = this.defaultString.split('');\r\n            }\r\n        } else {\r\n            // Control flashing of the score on reaching acheivement.\r\n            if (this.flashIterations <= this.config.FLASH_ITERATIONS) {\r\n                this.flashTimer += deltaTime;\r\n\r\n                if (this.flashTimer < this.config.FLASH_DURATION) {\r\n                    paint = false;\r\n                } else if (this.flashTimer >\r\n                    this.config.FLASH_DURATION * 2) {\r\n                    this.flashTimer = 0;\r\n                    this.flashIterations++;\r\n                }\r\n            } else {\r\n                this.achievement = false;\r\n                this.flashIterations = 0;\r\n                this.flashTimer = 0;\r\n            }\r\n        }\r\n\r\n        // Draw the digits if not flashing.\r\n        if (paint) {\r\n            for (var i = this.digits.length - 1; i >= 0; i--) {\r\n                this.draw(i, parseInt(this.digits[i]));\r\n            }\r\n        }\r\n\r\n        this.drawHighScore();\r\n        return playSound;\r\n    },\r\n\r\n    /**\r\n     * Draw the high score.\r\n     */\r\n    drawHighScore: function () {\r\n        this.canvasCtx.save();\r\n        this.canvasCtx.globalAlpha = .8;\r\n        for (var i = this.highScore.length - 1; i >= 0; i--) {\r\n            this.draw(i, parseInt(this.highScore[i], 10), true);\r\n        }\r\n        this.canvasCtx.restore();\r\n    },\r\n\r\n    /**\r\n     * Set the highscore as a array string.\r\n     * Position of char in the sprite: H - 10, I - 11.\r\n     * @param {number} distance Distance ran in pixels.\r\n     */\r\n    setHighScore: function (distance) {\r\n        distance = this.getActualDistance(distance);\r\n        var highScoreStr = (this.defaultString +\r\n            distance).substr(-this.maxScoreUnits);\r\n\r\n        this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));\r\n    },\r\n\r\n    /**\r\n     * Reset the distance meter back to '00000'.\r\n     */\r\n    reset: function () {\r\n        this.update(0);\r\n        this.achievement = false;\r\n    }\r\n};\r\n\r\n\r\n\r\n//******************************************************************************\r\n\r\nmodule.exports = Runner;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/runner.js\n// module id = 1\n// module chunks = 0","var Cloud = require('./Cloud'),\r\n    HorizonLine = require('./HorizonLine'),\r\n    NightMode = require('./NightMode'),\r\n    utils = require('./utils'),\r\n    Obstacle = require('./Obstacle');\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\n\r\n/**\r\n     * Horizon background class.\r\n     * @param {HTMLCanvasElement} canvas\r\n     * @param {Object} spritePos Sprite positioning.\r\n     * @param {Object} dimensions Canvas dimensions.\r\n     * @param {number} gapCoefficient\r\n     * @constructor\r\n     */\r\n    function Horizon(canvas, spritePos, dimensions, gapCoefficient) {\r\n        this.canvas = canvas;\r\n        this.canvasCtx = this.canvas.getContext('2d');\r\n        this.config = Horizon.config;\r\n        this.dimensions = dimensions;\r\n        this.gapCoefficient = gapCoefficient;\r\n        this.obstacles = [];\r\n        this.obstacleHistory = [];\r\n        this.horizonOffsets = [0, 0];\r\n        this.cloudFrequency = this.config.CLOUD_FREQUENCY;\r\n        this.spritePos = spritePos;\r\n        this.nightMode = null;\r\n\r\n        // Cloud\r\n        this.clouds = [];\r\n        this.cloudSpeed = this.config.BG_CLOUD_SPEED;\r\n\r\n        // Horizon\r\n        this.horizonLine = null;\r\n        this.init();\r\n    };\r\n\r\n\r\n    /**\r\n     * Horizon config.\r\n     * @enum {number}\r\n     */\r\n    Horizon.config = {\r\n        BG_CLOUD_SPEED: 0.2,\r\n        BUMPY_THRESHOLD: .3,\r\n        CLOUD_FREQUENCY: .5,\r\n        HORIZON_HEIGHT: 16,\r\n        MAX_CLOUDS: 6\r\n    };\r\n\r\n    Horizon.prototype = {\r\n        /**\r\n         * Initialise the horizon. Just add the line and a cloud. No obstacles.\r\n         */\r\n        init: function () {\r\n            this.addCloud();\r\n            this.horizonLine = new HorizonLine(this.canvas, this.spritePos.HORIZON);\r\n            this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,\r\n                this.dimensions.WIDTH);\r\n        },\r\n\r\n        /**\r\n         * @param {number} deltaTime\r\n         * @param {number} currentSpeed\r\n         * @param {boolean} updateObstacles Used as an override to prevent\r\n         *     the obstacles from being updated / added. This happens in the\r\n         *     ease in section.\r\n         * @param {boolean} showNightMode Night mode activated.\r\n         */\r\n        update: function (deltaTime, currentSpeed, updateObstacles, showNightMode) {\r\n            this.runningTime += deltaTime;\r\n            this.horizonLine.update(deltaTime, currentSpeed);\r\n            this.nightMode.update(showNightMode);\r\n            this.updateClouds(deltaTime, currentSpeed);\r\n\r\n            if (updateObstacles) {\r\n                this.updateObstacles(deltaTime, currentSpeed);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Update the cloud positions.\r\n         * @param {number} deltaTime\r\n         * @param {number} currentSpeed\r\n         */\r\n        updateClouds: function (deltaTime, speed) {\r\n            var cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;\r\n            var numClouds = this.clouds.length;\r\n\r\n            if (numClouds) {\r\n                for (var i = numClouds - 1; i >= 0; i--) {\r\n                    this.clouds[i].update(cloudSpeed);\r\n                }\r\n\r\n                var lastCloud = this.clouds[numClouds - 1];\r\n\r\n                // Check for adding a new cloud.\r\n                if (numClouds < this.config.MAX_CLOUDS &&\r\n                    (this.dimensions.WIDTH - lastCloud.xPos) > lastCloud.cloudGap &&\r\n                    this.cloudFrequency > Math.random()) {\r\n                    this.addCloud();\r\n                }\r\n\r\n                // Remove expired clouds.\r\n                this.clouds = this.clouds.filter(function (obj) {\r\n                    return !obj.remove;\r\n                });\r\n            } else {\r\n                this.addCloud();\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Update the obstacle positions.\r\n         * @param {number} deltaTime\r\n         * @param {number} currentSpeed\r\n         */\r\n        updateObstacles: function (deltaTime, currentSpeed) {\r\n            // Obstacles, move to Horizon layer.\r\n            var updatedObstacles = this.obstacles.slice(0);\r\n\r\n            for (var i = 0; i < this.obstacles.length; i++) {\r\n                var obstacle = this.obstacles[i];\r\n                obstacle.update(deltaTime, currentSpeed);\r\n\r\n                // Clean up existing obstacles.\r\n                if (obstacle.remove) {\r\n                    updatedObstacles.shift();\r\n                }\r\n            }\r\n            this.obstacles = updatedObstacles;\r\n\r\n            if (this.obstacles.length > 0) {\r\n                var lastObstacle = this.obstacles[this.obstacles.length - 1];\r\n\r\n                if (lastObstacle && !lastObstacle.followingObstacleCreated &&\r\n                    lastObstacle.isVisible() &&\r\n                    (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <\r\n                    this.dimensions.WIDTH) {\r\n                    this.addNewObstacle(currentSpeed);\r\n                    lastObstacle.followingObstacleCreated = true;\r\n                }\r\n            } else {\r\n                // Create new obstacles.\r\n                this.addNewObstacle(currentSpeed);\r\n            }\r\n        },\r\n\r\n        removeFirstObstacle: function () {\r\n            this.obstacles.shift();\r\n        },\r\n\r\n        /**\r\n         * Add a new obstacle.\r\n         * @param {number} currentSpeed\r\n         */\r\n        addNewObstacle: function (currentSpeed) {\r\n            var obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);\r\n            var obstacleType = Obstacle.types[obstacleTypeIndex];\r\n\r\n            // Check for multiples of the same type of obstacle.\r\n            // Also check obstacle is available at current speed.\r\n            if (this.duplicateObstacleCheck(obstacleType.type) ||\r\n                currentSpeed < obstacleType.minSpeed) {\r\n                this.addNewObstacle(currentSpeed);\r\n            } else {\r\n                var obstacleSpritePos = this.spritePos[obstacleType.type];\r\n\r\n                this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType,\r\n                    obstacleSpritePos, this.dimensions,\r\n                    this.gapCoefficient, currentSpeed, obstacleType.width));\r\n\r\n                this.obstacleHistory.unshift(obstacleType.type);\r\n\r\n                if (this.obstacleHistory.length > 1) {\r\n                    this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns whether the previous two obstacles are the same as the next one.\r\n         * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.\r\n         * @return {boolean}\r\n         */\r\n        duplicateObstacleCheck: function (nextObstacleType) {\r\n            var duplicateCount = 0;\r\n\r\n            for (var i = 0; i < this.obstacleHistory.length; i++) {\r\n                duplicateCount = this.obstacleHistory[i] == nextObstacleType ?\r\n                    duplicateCount + 1 : 0;\r\n            }\r\n            return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;\r\n        },\r\n\r\n        /**\r\n         * Reset the horizon layer.\r\n         * Remove existing obstacles and reposition the horizon line.\r\n         */\r\n        reset: function () {\r\n            this.obstacles = [];\r\n            this.horizonLine.reset();\r\n            this.nightMode.reset();\r\n        },\r\n\r\n        /**\r\n         * Update the canvas width and scaling.\r\n         * @param {number} width Canvas width.\r\n         * @param {number} height Canvas height.\r\n         */\r\n        resize: function (width, height) {\r\n            this.canvas.width = width;\r\n            this.canvas.height = height;\r\n        },\r\n\r\n        /**\r\n         * Add a new cloud to the horizon.\r\n         */\r\n        addCloud: function () {\r\n            this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,\r\n                this.dimensions.WIDTH));\r\n        }\r\n    };\r\n\r\n    module.exports = Horizon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Horizon.js\n// module id = 2\n// module chunks = 0","var utils = require('./utils');\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\n\r\n/**\r\n * Cloud background item.\r\n * Similar to an obstacle object but without collision boxes.\r\n * @param {HTMLCanvasElement} canvas Canvas element.\r\n * @param {Object} spritePos Position of image in sprite.\r\n * @param {number} containerWidth\r\n */\r\nfunction Cloud(canvas, spritePos, containerWidth) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = this.canvas.getContext('2d');\r\n    this.spritePos = spritePos;\r\n    this.containerWidth = containerWidth;\r\n    this.xPos = containerWidth;\r\n    this.yPos = 0;\r\n    this.remove = false;\r\n    this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP,\r\n        Cloud.config.MAX_CLOUD_GAP);\r\n\r\n    this.init();\r\n};\r\n\r\n\r\n/**\r\n * Cloud object config.\r\n * @enum {number}\r\n */\r\nCloud.config = {\r\n    HEIGHT: 14,\r\n    MAX_CLOUD_GAP: 400,\r\n    MAX_SKY_LEVEL: 30,\r\n    MIN_CLOUD_GAP: 100,\r\n    MIN_SKY_LEVEL: 71,\r\n    WIDTH: 46\r\n};\r\n\r\nCloud.prototype = {\r\n    /**\r\n     * Initialise the cloud. Sets the Cloud height.\r\n     */\r\n    init: function () {\r\n        this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,\r\n            Cloud.config.MIN_SKY_LEVEL);\r\n        this.draw();\r\n    },\r\n\r\n    /**\r\n     * Draw the cloud.\r\n     */\r\n    draw: function () {\r\n        this.canvasCtx.save();\r\n        var sourceWidth = Cloud.config.WIDTH;\r\n        var sourceHeight = Cloud.config.HEIGHT;\r\n\r\n        if (IS_HIDPI) {\r\n            sourceWidth = sourceWidth * 2;\r\n            sourceHeight = sourceHeight * 2;\r\n        }\r\n\r\n        this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,\r\n            this.spritePos.y,\r\n            sourceWidth, sourceHeight,\r\n            this.xPos, this.yPos,\r\n            Cloud.config.WIDTH, Cloud.config.HEIGHT);\r\n\r\n        this.canvasCtx.restore();\r\n    },\r\n\r\n    /**\r\n     * Update the cloud position.\r\n     * @param {number} speed\r\n     */\r\n    update: function (speed) {\r\n        if (!this.remove) {\r\n            this.xPos -= Math.ceil(speed);\r\n            this.draw();\r\n\r\n            // Mark as removeable if no longer in the canvas.\r\n            if (!this.isVisible()) {\r\n                this.remove = true;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check if the cloud is visible on the stage.\r\n     * @return {boolean}\r\n     */\r\n    isVisible: function () {\r\n        return this.xPos + Cloud.config.WIDTH > 0;\r\n    }\r\n};\r\n\r\nmodule.exports = Cloud;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Cloud.js\n// module id = 3\n// module chunks = 0","module.exports = {\r\n    /**\r\n     * Get random number.\r\n     * @param {number} min\r\n     * @param {number} max\r\n     * @param {number}\r\n     */\r\n    getRandomNum: function (min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    },\r\n    IS_HIDPI: window.devicePixelRatio > 1,\r\n    FPS: 60\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 4\n// module chunks = 0","var utils = require('./utils');\r\n\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\nvar FPS = utils.FPS;\r\n/**\r\n * Horizon Line.\r\n * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {Object} spritePos Horizon position in sprite.\r\n * @constructor\r\n */\r\nfunction HorizonLine(canvas, spritePos) {\r\n    this.spritePos = spritePos;\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.sourceDimensions = {};\r\n    this.dimensions = HorizonLine.dimensions;\r\n    this.sourceXPos = [this.spritePos.x, this.spritePos.x +\r\n        this.dimensions.WIDTH];\r\n    this.xPos = [];\r\n    this.yPos = 0;\r\n    this.bumpThreshold = 0.5;\r\n\r\n    this.setSourceDimensions();\r\n    this.draw();\r\n};\r\n\r\n\r\n/**\r\n * Horizon line dimensions.\r\n * @enum {number}\r\n */\r\nHorizonLine.dimensions = {\r\n    WIDTH: 600,\r\n    HEIGHT: 12,\r\n    YPOS: 127\r\n};\r\n\r\n\r\nHorizonLine.prototype = {\r\n    /**\r\n     * Set the source dimensions of the horizon line.\r\n     */\r\n    setSourceDimensions: function () {\r\n\r\n        for (var dimension in HorizonLine.dimensions) {\r\n            if (IS_HIDPI) {\r\n                if (dimension != 'YPOS') {\r\n                    this.sourceDimensions[dimension] =\r\n                        HorizonLine.dimensions[dimension] * 2;\r\n                }\r\n            } else {\r\n                this.sourceDimensions[dimension] =\r\n                    HorizonLine.dimensions[dimension];\r\n            }\r\n            this.dimensions[dimension] = HorizonLine.dimensions[dimension];\r\n        }\r\n\r\n        this.xPos = [0, HorizonLine.dimensions.WIDTH];\r\n        this.yPos = HorizonLine.dimensions.YPOS;\r\n    },\r\n\r\n    /**\r\n     * Return the crop x position of a type.\r\n     */\r\n    getRandomType: function () {\r\n        return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;\r\n    },\r\n\r\n    /**\r\n     * Draw the horizon line.\r\n     */\r\n    draw: function () {\r\n        this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],\r\n            this.spritePos.y,\r\n            this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,\r\n            this.xPos[0], this.yPos,\r\n            this.dimensions.WIDTH, this.dimensions.HEIGHT);\r\n\r\n        this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],\r\n            this.spritePos.y,\r\n            this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,\r\n            this.xPos[1], this.yPos,\r\n            this.dimensions.WIDTH, this.dimensions.HEIGHT);\r\n    },\r\n\r\n    /**\r\n     * Update the x position of an indivdual piece of the line.\r\n     * @param {number} pos Line position.\r\n     * @param {number} increment\r\n     */\r\n    updateXPos: function (pos, increment) {\r\n        var line1 = pos;\r\n        var line2 = pos == 0 ? 1 : 0;\r\n\r\n        this.xPos[line1] -= increment;\r\n        this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;\r\n\r\n        if (this.xPos[line1] <= -this.dimensions.WIDTH) {\r\n            this.xPos[line1] += this.dimensions.WIDTH * 2;\r\n            this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;\r\n            this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Update the horizon line.\r\n     * @param {number} deltaTime\r\n     * @param {number} speed\r\n     */\r\n    update: function (deltaTime, speed) {\r\n        var increment = Math.floor(speed * (FPS / 1000) * deltaTime);\r\n\r\n        if (this.xPos[0] <= 0) {\r\n            this.updateXPos(0, increment);\r\n        } else {\r\n            this.updateXPos(1, increment);\r\n        }\r\n        this.draw();\r\n    },\r\n\r\n    /**\r\n     * Reset horizon to the starting position.\r\n     */\r\n    reset: function () {\r\n        this.xPos[0] = 0;\r\n        this.xPos[1] = HorizonLine.dimensions.WIDTH;\r\n    }\r\n};\r\n\r\nmodule.exports = HorizonLine;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HorizonLine.js\n// module id = 5\n// module chunks = 0","\r\nvar utils = require('./utils');\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\n/**\r\n * Nightmode shows a moon and stars on the horizon.\r\n */\r\nfunction NightMode(canvas, spritePos, containerWidth) {\r\n    this.spritePos = spritePos;\r\n    this.canvas = canvas;\r\n    this.canvasCtx = canvas.getContext('2d');\r\n    this.xPos = containerWidth - 50;\r\n    this.yPos = 30;\r\n    this.currentPhase = 0;\r\n    this.opacity = 0;\r\n    this.containerWidth = containerWidth;\r\n    this.stars = [];\r\n    this.drawStars = false;\r\n    this.placeStars();\r\n};\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nNightMode.config = {\r\n    FADE_SPEED: 0.035,\r\n    HEIGHT: 40,\r\n    MOON_SPEED: 0.25,\r\n    NUM_STARS: 2,\r\n    STAR_SIZE: 9,\r\n    STAR_SPEED: 0.3,\r\n    STAR_MAX_Y: 70,\r\n    WIDTH: 20\r\n};\r\n\r\nNightMode.phases = [140, 120, 100, 60, 40, 20, 0];\r\n\r\nNightMode.prototype = {\r\n    /**\r\n     * Update moving moon, changing phases.\r\n     * @param {boolean} activated Whether night mode is activated.\r\n     * @param {number} delta\r\n     */\r\n    update: function (activated, delta) {\r\n        // Moon phase.\r\n        if (activated && this.opacity == 0) {\r\n            this.currentPhase++;\r\n\r\n            if (this.currentPhase >= NightMode.phases.length) {\r\n                this.currentPhase = 0;\r\n            }\r\n        }\r\n\r\n        // Fade in / out.\r\n        if (activated && (this.opacity < 1 || this.opacity == 0)) {\r\n            this.opacity += NightMode.config.FADE_SPEED;\r\n        } else if (this.opacity > 0) {\r\n            this.opacity -= NightMode.config.FADE_SPEED;\r\n        }\r\n\r\n        // Set moon positioning.\r\n        if (this.opacity > 0) {\r\n            this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);\r\n\r\n            // Update stars.\r\n            if (this.drawStars) {\r\n                for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\r\n                    this.stars[i].x = this.updateXPos(this.stars[i].x,\r\n                        NightMode.config.STAR_SPEED);\r\n                }\r\n            }\r\n            this.draw();\r\n        } else {\r\n            this.opacity = 0;\r\n            this.placeStars();\r\n        }\r\n        this.drawStars = true;\r\n    },\r\n\r\n    updateXPos: function (currentPos, speed) {\r\n        if (currentPos < -NightMode.config.WIDTH) {\r\n            currentPos = this.containerWidth;\r\n        } else {\r\n            currentPos -= speed;\r\n        }\r\n        return currentPos;\r\n    },\r\n\r\n    draw: function () {\r\n        var moonSourceWidth = this.currentPhase == 3 ? NightMode.config.WIDTH * 2 :\r\n            NightMode.config.WIDTH;\r\n        var moonSourceHeight = NightMode.config.HEIGHT;\r\n        var moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];\r\n        var moonOutputWidth = moonSourceWidth;\r\n        var starSize = NightMode.config.STAR_SIZE;\r\n        var starSourceX = Runner.spriteDefinition.LDPI.STAR.x;\r\n\r\n        if (IS_HIDPI) {\r\n            moonSourceWidth *= 2;\r\n            moonSourceHeight *= 2;\r\n            moonSourceX = this.spritePos.x +\r\n                (NightMode.phases[this.currentPhase] * 2);\r\n            starSize *= 2;\r\n            starSourceX = Runner.spriteDefinition.HDPI.STAR.x;\r\n        }\r\n\r\n        this.canvasCtx.save();\r\n        this.canvasCtx.globalAlpha = this.opacity;\r\n\r\n        // Stars.\r\n        if (this.drawStars) {\r\n            for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\r\n                this.canvasCtx.drawImage(Runner.imageSprite,\r\n                    starSourceX, this.stars[i].sourceY, starSize, starSize,\r\n                    Math.round(this.stars[i].x), this.stars[i].y,\r\n                    NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);\r\n            }\r\n        }\r\n\r\n        // Moon.\r\n        this.canvasCtx.drawImage(Runner.imageSprite, moonSourceX,\r\n            this.spritePos.y, moonSourceWidth, moonSourceHeight,\r\n            Math.round(this.xPos), this.yPos,\r\n            moonOutputWidth, NightMode.config.HEIGHT);\r\n\r\n        this.canvasCtx.globalAlpha = 1;\r\n        this.canvasCtx.restore();\r\n    },\r\n\r\n    // Do star placement.\r\n    placeStars: function () {\r\n        var segmentSize = Math.round(this.containerWidth /\r\n            NightMode.config.NUM_STARS);\r\n\r\n        for (var i = 0; i < NightMode.config.NUM_STARS; i++) {\r\n            this.stars[i] = {};\r\n            this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));\r\n            this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);\r\n\r\n            if (IS_HIDPI) {\r\n                this.stars[i].sourceY = Runner.spriteDefinition.HDPI.STAR.y +\r\n                    NightMode.config.STAR_SIZE * 2 * i;\r\n            } else {\r\n                this.stars[i].sourceY = Runner.spriteDefinition.LDPI.STAR.y +\r\n                    NightMode.config.STAR_SIZE * i;\r\n            }\r\n        }\r\n    },\r\n\r\n    reset: function () {\r\n        this.currentPhase = 0;\r\n        this.opacity = 0;\r\n        this.update(false);\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = NightMode;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NightMode.js\n// module id = 6\n// module chunks = 0","var utils = require('./utils');\r\n\r\nvar getRandomNum = utils.getRandomNum;\r\nvar CollisionBox = require('./CollisionBox');\r\n/** @const */\r\nvar IS_HIDPI = utils.IS_HIDPI;\r\nvar FPS = utils.FPS;\r\n\r\n/**\r\n * Obstacle.\r\n * @param {HTMLCanvasCtx} canvasCtx\r\n * @param {Obstacle.type} type\r\n * @param {Object} spritePos Obstacle position in sprite.\r\n * @param {Object} dimensions\r\n * @param {number} gapCoefficient Mutipler in determining the gap.\r\n * @param {number} speed\r\n * @param {number} opt_xOffset\r\n */\r\nfunction Obstacle(canvasCtx, type, spriteImgPos, dimensions,\r\n    gapCoefficient, speed, opt_xOffset) {\r\n\r\n    this.canvasCtx = canvasCtx;\r\n    this.spritePos = spriteImgPos;\r\n    this.typeConfig = type;\r\n    this.gapCoefficient = gapCoefficient;\r\n    this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);\r\n    this.dimensions = dimensions;\r\n    this.remove = false;\r\n    this.xPos = dimensions.WIDTH + (opt_xOffset || 0);\r\n    this.yPos = 0;\r\n    this.width = 0;\r\n    this.collisionBoxes = [];\r\n    this.gap = 0;\r\n    this.speedOffset = 0;\r\n\r\n    // For animated obstacles.\r\n    this.currentFrame = 0;\r\n    this.timer = 0;\r\n\r\n    this.init(speed);\r\n};\r\n\r\n/**\r\n * Coefficient for calculating the maximum gap.\r\n * @const\r\n */\r\nObstacle.MAX_GAP_COEFFICIENT = 1.5;\r\n\r\n/**\r\n * Maximum obstacle grouping count.\r\n * @const\r\n */\r\nObstacle.MAX_OBSTACLE_LENGTH = 3,\r\n\r\n\r\n    Obstacle.prototype = {\r\n        /**\r\n         * Initialise the DOM for the obstacle.\r\n         * @param {number} speed\r\n         */\r\n        init: function (speed) {\r\n            this.cloneCollisionBoxes();\r\n\r\n            // Only allow sizing if we're at the right speed.\r\n            if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {\r\n                this.size = 1;\r\n            }\r\n\r\n            this.width = this.typeConfig.width * this.size;\r\n\r\n            // Check if obstacle can be positioned at various heights.\r\n            if (Array.isArray(this.typeConfig.yPos)) {\r\n                var yPosConfig = IS_MOBILE ? this.typeConfig.yPosMobile :\r\n                    this.typeConfig.yPos;\r\n                this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];\r\n            } else {\r\n                this.yPos = this.typeConfig.yPos;\r\n            }\r\n\r\n            this.draw();\r\n\r\n            // Make collision box adjustments,\r\n            // Central box is adjusted to the size as one box.\r\n            //      ____        ______        ________\r\n            //    _|   |-|    _|     |-|    _|       |-|\r\n            //   | |<->| |   | |<--->| |   | |<----->| |\r\n            //   | | 1 | |   | |  2  | |   | |   3   | |\r\n            //   |_|___|_|   |_|_____|_|   |_|_______|_|\r\n            //\r\n            if (this.size > 1) {\r\n                this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -\r\n                    this.collisionBoxes[2].width;\r\n                this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;\r\n            }\r\n\r\n            // For obstacles that go at a different speed from the horizon.\r\n            if (this.typeConfig.speedOffset) {\r\n                this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :\r\n                    -this.typeConfig.speedOffset;\r\n            }\r\n\r\n            this.gap = this.getGap(this.gapCoefficient, speed);\r\n        },\r\n\r\n        /**\r\n         * Draw and crop based on size.\r\n         */\r\n        draw: function () {\r\n            var sourceWidth = this.typeConfig.width;\r\n            var sourceHeight = this.typeConfig.height;\r\n\r\n            if (IS_HIDPI) {\r\n                sourceWidth = sourceWidth * 2;\r\n                sourceHeight = sourceHeight * 2;\r\n            }\r\n\r\n            // X position in sprite.\r\n            var sourceX = (sourceWidth * this.size) * (0.5 * (this.size - 1)) +\r\n                this.spritePos.x;\r\n\r\n            // Animation frames.\r\n            if (this.currentFrame > 0) {\r\n                sourceX += sourceWidth * this.currentFrame;\r\n            }\r\n\r\n            this.canvasCtx.drawImage(Runner.imageSprite,\r\n                sourceX, this.spritePos.y,\r\n                sourceWidth * this.size, sourceHeight,\r\n                this.xPos, this.yPos,\r\n                this.typeConfig.width * this.size, this.typeConfig.height);\r\n        },\r\n\r\n        /**\r\n         * Obstacle frame update.\r\n         * @param {number} deltaTime\r\n         * @param {number} speed\r\n         */\r\n        update: function (deltaTime, speed) {\r\n            if (!this.remove) {\r\n                if (this.typeConfig.speedOffset) {\r\n                    speed += this.speedOffset;\r\n                }\r\n                this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);\r\n\r\n                // Update frame\r\n                if (this.typeConfig.numFrames) {\r\n                    this.timer += deltaTime;\r\n                    if (this.timer >= this.typeConfig.frameRate) {\r\n                        this.currentFrame =\r\n                            this.currentFrame == this.typeConfig.numFrames - 1 ?\r\n                                0 : this.currentFrame + 1;\r\n                        this.timer = 0;\r\n                    }\r\n                }\r\n                this.draw();\r\n\r\n                if (!this.isVisible()) {\r\n                    this.remove = true;\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Calculate a random gap size.\r\n         * - Minimum gap gets wider as speed increses\r\n         * @param {number} gapCoefficient\r\n         * @param {number} speed\r\n         * @return {number} The gap size.\r\n         */\r\n        getGap: function (gapCoefficient, speed) {\r\n            var minGap = Math.round(this.width * speed +\r\n                this.typeConfig.minGap * gapCoefficient);\r\n            var maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);\r\n            return getRandomNum(minGap, maxGap);\r\n        },\r\n\r\n        /**\r\n         * Check if obstacle is visible.\r\n         * @return {boolean} Whether the obstacle is in the game area.\r\n         */\r\n        isVisible: function () {\r\n            return this.xPos + this.width > 0;\r\n        },\r\n\r\n        /**\r\n         * Make a copy of the collision boxes, since these will change based on\r\n         * obstacle type and size.\r\n         */\r\n        cloneCollisionBoxes: function () {\r\n            var collisionBoxes = this.typeConfig.collisionBoxes;\r\n\r\n            for (var i = collisionBoxes.length - 1; i >= 0; i--) {\r\n                this.collisionBoxes[i] = new CollisionBox(collisionBoxes[i].x,\r\n                    collisionBoxes[i].y, collisionBoxes[i].width,\r\n                    collisionBoxes[i].height);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n/**\r\n * Obstacle definitions.\r\n * minGap: minimum pixel space betweeen obstacles.\r\n * multipleSpeed: Speed at which multiples are allowed.\r\n * speedOffset: speed faster / slower than the horizon.\r\n * minSpeed: Minimum speed which the obstacle can make an appearance.\r\n */\r\nObstacle.types = [\r\n    {\r\n        type: 'CACTUS_SMALL',\r\n        width: 17,\r\n        height: 35,\r\n        yPos: 105,\r\n        multipleSpeed: 4,\r\n        minGap: 120,\r\n        minSpeed: 0,\r\n        collisionBoxes: [\r\n            new CollisionBox(0, 7, 5, 27),\r\n            new CollisionBox(4, 0, 6, 34),\r\n            new CollisionBox(10, 4, 7, 14)\r\n        ]\r\n    },\r\n    {\r\n        type: 'CACTUS_LARGE',\r\n        width: 25,\r\n        height: 50,\r\n        yPos: 90,\r\n        multipleSpeed: 7,\r\n        minGap: 120,\r\n        minSpeed: 0,\r\n        collisionBoxes: [\r\n            new CollisionBox(0, 12, 7, 38),\r\n            new CollisionBox(8, 0, 7, 49),\r\n            new CollisionBox(13, 10, 10, 38)\r\n        ]\r\n    },\r\n    {\r\n        type: 'PTERODACTYL',\r\n        width: 46,\r\n        height: 40,\r\n        yPos: [100, 75, 50], // Variable height.\r\n        yPosMobile: [100, 50], // Variable height mobile.\r\n        multipleSpeed: 999,\r\n        minSpeed: 8.5,\r\n        minGap: 150,\r\n        collisionBoxes: [\r\n            new CollisionBox(15, 15, 16, 5),\r\n            new CollisionBox(18, 21, 24, 6),\r\n            new CollisionBox(2, 14, 4, 3),\r\n            new CollisionBox(6, 10, 4, 7),\r\n            new CollisionBox(10, 8, 6, 9)\r\n        ],\r\n        numFrames: 2,\r\n        frameRate: 1000 / 6,\r\n        speedOffset: .8\r\n    }\r\n];\r\n\r\nmodule.exports = Obstacle;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Obstacle.js\n// module id = 7\n// module chunks = 0","/**\r\n * Collision box object.\r\n * @param {number} x X position.\r\n * @param {number} y Y Position.\r\n * @param {number} w Width.\r\n * @param {number} h Height.\r\n */\r\nfunction CollisionBox(x, y, w, h) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = w;\r\n    this.height = h;\r\n};\r\n\r\nmodule.exports = CollisionBox;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CollisionBox.js\n// module id = 8\n// module chunks = 0","function StartBtn(canvas) {\r\n    this.canvas = canvas;\r\n    this.canvasCtx = this.canvas.getContext('2d');\r\n    this.canvasCtx.drawImage(Runner.imageSprite,20,20);\r\n}\r\n\r\nmodule.exports = StartBtn;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/StartBtn.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}